\documentclass{article}

\usepackage[backend=bibtex,sorting=nyt]{biblatex}
\usepackage[margin=1in]{geometry}

\addbibresource{references.bib}

\title{Honors Thesis Ideas}
\author{Taylor Blau}
\date{January, 2019}

\begin{document}
  \maketitle

  \section{Verifying CRDT Safety Properties}
  \textit{Conflict-free replicated data types} (CRDTs) have become popular in
  distributed systems literature for allowing multiple systems to act
  independently in a distributed setting, while retaining strong eventual
  consistency~\cite{shapiro11}. In particular, they do so by forming a
  \textit{monotone join semi-lattice} over possible states, gossiping about
  their current state, and exporting a $\textsc{Merge}(\cdot)$ operation, which
  is (1) commutative, (2) associative, and (3) idempotent.

  Some prior work exists in the verification of different primitive
  CRDTs~\cite{gomes17,zeller14}. Some extensions of this line of work could
  include:
  \begin{enumerate}
    \item Verifying the \textit{composition} of several primitive CRDTs, instead
      of individual CRDTs.
    \item Proof automation in Idris via elaborator
      reflection~\cite{christiansen16}.
    \item Inferring a CRDT-based representation of a given program, and then
      using that to replicate that program's state via a CRDT, verifying that it
      is correct in a distributed setting. Perhaps a user of this tool would
      specify correctness proofs of their own program that do not involve CRDT
      properties, and we could \textit{lift} the proof into a distributed
      setting.
  \end{enumerate}

  Another approach would be to try and recreate the work in~\cite{gomes17} in a
  different proof-assisted language, such as Idris~\cite{brady13} and seeing
  what changes compared to existing proofs in Isabelle and Coq. It has been my
  experience that Idris offers the user a richer realization of the program
  under proof by handing the power of dependent types to the user, rather than a
  tactic-style manipulation of proof terms.

  This approach produces an artifact which is of the author's writing directly,
  as opposed to an extracted form of the program written in Coq.

  \subsection{Verifying alternative implementation models}
  The model of CRDTs as described above is known as the \textit{state-based}
  model, in which a CRDT's gossip includes a serialized representation of its
  whole internal state. This classic model exchanges an ease of implementation
  for a potentially much less efficient payload size.

  To address this, there are two alternative models in the literature
  currently: \textit{operation-based} and
  \textit{$\delta$-CRDTs}~\cite{shapiro11,almeida18}. In the operation-based
  setting, an operation is ``prepared'' and sent to all other CRDTs which apply
  the operation locally. This approach often yields smaller payloads, but
  requires a stronger set of network semantics ensuring that all messages are
  delivered exactly once.

  $\delta$-CRDTs send only the \textit{result} of applying an operation, not
  their entire payload~\cite{almeida18}. This always yields a smaller payload
  size, but does not require a stronger network, as do operation-based CRDTs.
  Additionally, $\delta$-CRDTs have the nice property that they can form
  \textit{delta-groups}, or they can merge their own updates together to send
  an aggregate payload. Interesting work here could include the following:
  \begin{enumerate}
    \item Translating the proofs offered in the paper to a machine-checked
      variant.
    \item Any interesting application of these proofs to any other idea here,
      e.g., a technique for automatically translating state-based CRDTs to
      $\delta$-CRDTs, or additionally verifying that they exhibit equivalent
      behavior\footnotemark.
  \end{enumerate}

  \footnotetext{Of the ideas that are described here, this appears to be the
    most novel.}

  \section{Efficient Garbage Collection for CRDTs}
  One problem that CRDTs suffer from under certain settings is large payload
  size. Because CRDT states form a \textit{monotone} join semi-lattice, there
  can often arise situations where much of the payload can be eliminated.

  Consider the PN-counter (positive/negative counter), commonly implemented as
  two grow-only counters (each representing the number of increments and
  decrements, respectively). It might be the case that, after some period of
  time, consistency has been reached and all nodes in a system agree that the
  count is $\langle12,7\rangle$ (i.e., $12-7=5$). In this case, we can perform a
  \textit{garbage collection} and take $\langle12,7\rangle\to\langle5,0\rangle$,
  thus allowing CRDTs in the system to avoid sending part of the payload.

  Interesting work on this area may include the following:
  \begin{enumerate}
    \item Results on how to perform efficient garbage collection on primitive
      and compositional CRDTs, and a procedure for doing so in a distributed
      environment.
    \item Correctness proofs (see: above) that a CRDT network retains its state
      even after garbage collection. (Perhaps this idea could be combined with
      any other one in the previous section, too).
  \end{enumerate}

  Work in this area will be challenging, because garbage collection (as
  described here) requires a period in which the members of a network are
  communicating synchronously, and guarantee that messages will be received
  (e.g., not dropped, duplicated, etc).

  \printbibliography
\end{document}
