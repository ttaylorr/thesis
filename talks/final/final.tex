\ifdefined\handout
  \documentclass[aspectratio=169,compress,handout]{beamer}
\else
  \documentclass[aspectratio=169,compress]{beamer}
\fi

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[]{hyperref}
\usepackage[square,sort,comma,numbers]{natbib}
\usepackage{xcolor}
\usepackage{xspace}

\newcommand*{\TODO}[1][]{\text{\color{red} TODO {#1}}}

\newcommand*{\CRDT}{\textsf{CRDT}\xspace}
\newcommand*{\CRDTs}{\textsf{CRDTs}\xspace}
\newcommand*{\CC}{\textsf{CC}\xspace}
\newcommand*{\EC}{\textsf{EC}\xspace}
\newcommand*{\SEC}{\textsf{SEC}\xspace}

\newcommand*{\fst}{\textsf{fst}\xspace}
\newcommand*{\snd}{\textsf{snd}\xspace}

\newtheorem{maxim}{Maxim}[theorem]

\setbeamercovered{transparent}
\usetheme{CambridgeUS}
\usecolortheme{dolphin}

\setcitestyle{authoryear}

\hypersetup{%
  pdfborder={0 0 0},colorlinks=true,citecolor=purple,linkcolor=
}

\title{Verifying Strong Eventual Consistency\\ in $\delta$-\CRDTs}
\author{Taylor Blau}
\institute{University of Washington}
\date{June, 2020}

\begin{document}
  \frame{\titlepage}

  \section{Introduction}

  \begin{frame}
    \frametitle{Contributions}

    This thesis:
    \begin{itemize}[<+->]
      \item Mechanized proofs in Isabelle that two $\delta$-state \CRDTs inhabit
        \SEC.
        \begin{itemize}
          \item Reuse a library for verifying operation-based \CRDTs of Gomes to
            reason about $\delta$-state \CRDTs.
          \item Weaken the network model of Gomes' to support duplicated
            messages.
        \end{itemize}
      \item Two reductions that allow us to reason about $\delta$-state \CRDTs
        in terms of operation-based \CRDTs.
      \item Two encodings of the latter reduction.
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{This talk}

    \begin{itemize}[<+->]
      \item Why distributed systems?
      \item Consistency models: classic approaches and relaxed approximations.
      \item \CRDTs: operation-, state- and $\delta$-state based, and the
        trade-offs each makes.
      \item Reductions between \CRDT variants.
      \item Mechanized proofs in two encodings.
      \item Conclusion.
    \end{itemize}
  \end{frame}

  \section{Motivation}

  \begin{frame}
    \frametitle{Distributed Systems}
    Why distributed systems?
    \begin{enumerate}
      \item \emph{Resiliency}. Tolerates failure of any one (or more)
        participants.
      \item \emph{Scalability}. Meeting the demands of an increased workload as
        simple as adding more hardware.
      \item \emph{Locality}. Service requests to varied locations by placing
        hardware close to where requests originate.
    \end{enumerate}
  \end{frame}

  \begin{frame}
    \frametitle{Distributed Consensus Algorithms}
    \begin{definition}[Distributed Consensus Algorithm,~\citet{howard20}]
      An algorithm is said to solve distributed consensus if it has the following
      three safety requirements:
      \begin{enumerate}
        \item<2-> \emph{Non-triviality}: The decided value must have been proposed by a
          participant.
        \item<3-> \emph{Safety}: Once a value has been decided, no other value will be
          decided.
        \item<4-> \emph{Safe learning}: If a participant learns a value, it must learn
          the decided value.
      \end{enumerate}
      In addition, it must satisfy the following two progress requirements:
      \begin{enumerate}
        \item<5-> \emph{Progress}: Under previously agreed-upon liveness conditions, if
          a value is proposed by a participant, then a value is eventually decided.
        \item<6-> \emph{Eventual learning}: Under the same conditions as above, if a
          value is decided, then that value must be eventually learned.
      \end{enumerate}
    \end{definition}
  \end{frame}

  \begin{frame}
    \frametitle{Distributed Consensus Algorithms}
    Two of the most popular algorithms in this field:
    \begin{itemize}
      \item Paxos~\citep{lamport98}
      \item Raft~\citep{ongaro14}
    \end{itemize}
    \pause
    ...are notoriously difficult to implement in practice~\citep{howard20}.
    \begin{itemize}
      \item<3-> Often the subject of advanced undergraduate-level courses in
        Distributed Systems (CSE 452).
      \item<4-> Subject of much mechanized verification
        effort~\citep{wilcox15,woos16}.
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{Distributed Consensus Algorithms}
    Why?
    \pause
    ...one possible answer: \emph{safety}.
    \begin{enumerate}[<+->]
      \item Coordinating a shared value between multiple replicas is difficult.
      \item Unreliable networks make this task even more difficult.
      \item Ensuing that all nodes learn the same value makes this even more
        difficult still.
    \end{enumerate}
  \end{frame}

  \section{Background}
  \subsection{Consistency Classes}
  \begin{frame}
    \frametitle{Eventual Consistency}
    Eventual consistency captures the informal notion that if all clients stop
    submitting updates to the system, all replicas in the system eventually
    reach the same value.

    \pause

    More formally:
    \begin{definition}[Eventual Consistency~\citep{shapiro11}]
      \begin{enumerate}[<+->]
        \item \emph{Eventual delivery}. An update delivered at some correct
          replica is eventually delivered at all replicas.
          \[
            \forall r_1, r_2.\, f \in (\textsf{delivered}~r_1) \Rightarrow
              \Diamond f \in (\textsf{delivered}~r_2)
          \]
        \item \emph{Convergence}. Correct replicas which have received the same
          \emph{set} of updates eventually reflect the same state.
          \[
            \forall r_1, r_2.\,~\square~(\textsf{delivered}~r_1) =
            (\textsf{delivered}~r_2) \Rightarrow \Diamond~\square~q(r_1) =
            q(r_2)
          \]
        \item \emph{Termination}. All method executions terminate.
      \end{enumerate}
    \end{definition}
  \end{frame}

  \begin{frame}
    \frametitle{Shortcomings of Eventual Consistency}

    \EC is a relatively weak form of consistency:

    \begin{enumerate}[<+->]
      \item \EC systems will sometimes execute an update immediately only to
        discover that it produces a conflict with some future update, and so
        frequent roll-backs may be performed~\citep{shapiro11}.
      \item \EC is merely a liveness guarantee. It does not impose any
        restriction on nodes which have received the same set or even sequence
        of messages.
    \end{enumerate}
  \end{frame}

  \begin{frame}
    \frametitle{Strong Eventual Consistency}

    \begin{definition}[Strong Eventual Consistency~\citep{shapiro11}]
      \begin{enumerate}[<+->]
        \item The system is \EC, per above guidelines.
        \item \emph{Strong convergence}. Any pair of replicas which have
          received the same set of messages must return the same value when
          queried immediately.
          \[
            \forall r_1, r_2.\, (\textsf{delivered}~r_1) =
              (\textsf{delivered}~r2) \Rightarrow q(r_1) = q(r_2)
          \]
      \end{enumerate}
    \end{definition}
  \end{frame}

  \begin{frame}
    \frametitle{Strong Eventual Consistency}

    Why is \SEC an appealing model?
    \begin{itemize}[<+->]
      \item No requirements on replicas which have not received the same
        sequence/set of updates.
      \item Trade linearizability for the ability to let replicas drift.
      \item Allow replicas which haven't yet received all updates to return an
        earlier value of the computation.
    \end{itemize}

    \pause
    Practical (in certain applications): offline synchronization, Facebook
    ``like'' counters, Cassandra, Redis, etc.
  \end{frame}

  \subsection{Conflict-free Replicated Datatypes}
  \begin{frame}
    \frametitle{Conflict-free Replicated Datatypes}

    \CRDTs are a class of replicated datatypes which implement
    \SEC~\cite{shapiro11}. There exist two broad classes:
    \begin{enumerate}[<+->]
      \item State-based \CRDTs. States form a join lattice, progress is made by
        sharing states with other replicas and merging with local state.
      \item Operation-based \CRDTs. Operations are serialized and delivered to
        all replicas in order.
    \end{enumerate}
  \end{frame}

  \subsection{state-based \CRDTs}
  \begin{frame}
    \frametitle{State-based \CRDTs}

    A state-based \CRDT is a 5-tuple $(S, s^0, q, u, m)$:
    \begin{enumerate}
      \item Individual \CRDT replicas each have some state $s^i \in S$ for $i
        \ge 0$, and is initially $s^0$.
      \item The value may be queried by any client or other replica by invoking
        $q$.
      \item It may be updated with $u$, which has a unique type per \CRDT
        object.
      \item Finally, $m$ merges the state of some other remote replica.
    \end{enumerate}
  \end{frame}

  \begin{frame}
    \frametitle{Example state-based \CRDT}

    Grow-only counter: increments a (grow-only) shared value over time, supports
    queries of the last-known value.
    \[
      \textsf{G-Counter}_s = \left\{\begin{aligned}
        S &: \mathbb{N}_0^{|\mathcal{I}|} \\
        s^0 &: \left[ 0, 0, \cdots, 0 \right] \\
        q &: \lambda s.\, \sum_{i \in \mathcal{I}} s(i) \\
        u &: \lambda s,i.\, s\left\{ i \mapsto s(i) + 1 \right\} \\
        m &: \lambda s_1, s_2.\, \left[ \max\left\{ s_1(i), s_2(i) \right\}: i \in \mathsf{dom}(s_1) \cup
        \mathsf{dom}(s_2) \right]
      \end{aligned}\right.
    \]
  \end{frame}

  \begin{frame}
    \frametitle{state-based properties}

    \begin{enumerate}[<+->]
      \item Crucially, the states of a given state-based \CRDT form a
        partially-ordered set $\langle S, \sqsubseteq \rangle$. This poset is
        used to form a join semi-lattice, where any finite subset of elements
        has a natural least upper-bound.

      \item For every state-based \CRDT whose states $S$ form some join
        semi-lattice (with join operator $\sqcup$), we assume that:
        \[
          m(s_1, s_2) = s_1 \sqcup s_2
        \]
    \end{enumerate}
  \end{frame}

  \begin{frame}
    \frametitle{state-based properties of $\sqcup$}

    $\sqcup$ must satisfy three mathematical identities:
    \begin{itemize}
      \item<2-> The operator is \emph{commutative}, i.e., that $s_1 \sqcup s_2 = s_2
        \sqcup s_1$, or that order does not matter.
      \item<3-> The operator is \emph{idempotent}, i.e., that $(s_1 \sqcup s_2)
        \sqcup s_2 = s_1 \sqcup s_2$, or that repeated updates reach a fixed point.
      \item<4-> Finally, the operator is \emph{associative}, i.e., that $s_1 \sqcup (s_2
        \sqcup s_3) = (s_1 \sqcup s_2) \sqcup s_3$, or that grouping of arguments
        does not matter.
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{state-based properties of $\sqcup$}
    ...why place these restrictions on $\sqcup$? Because:
    \begin{itemize}[<+->]
      \item<2-> Commutativity means that updates can be delivered from other
        replicas in any order.
      \item<3-> Idempotency means that updates can be delivered any number of times
        without changing the effect.
      \item<4-> Associativity means that updates can be applied in any grouping
        (useful for causality-preserving \CRDTs, but not studied further here).
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{Example state-based \CRDT}

    Grow-only counter: increments a (grow-only) shared value over time, supports
    queries of the last-known value.
    \[
      \textsf{G-Counter}_s = \left\{\begin{aligned}
        S &: \mathbb{N}_0^{|\mathcal{I}|}~\onslide<2->{\text{%
          \color{red}
          Each element in the lattice a vector of naturals.
        }} \\
        s^0 &: \left[ 0, 0, \cdots, 0 \right] \\
        q &: \lambda s.\, \sum_{i \in \mathcal{I}} s(i) \\
        u &: \lambda s,i.\, s\left\{ i \mapsto s(i) + 1 \right\} \\
        m &: \lambda s_1, s_2.\, \left[ \max\left\{ s_1(i), s_2(i) \right\}: i \in \mathsf{dom}(s_1) \cup
        \mathsf{dom}(s_2) \right] \\
          &~\onslide<3->{\text{%
            \color{red}
            Least upper bound $\sqcup$ defined by the element-wise maximum.
          }}
      \end{aligned}\right.
    \]
  \end{frame}

  \begin{frame}
    \frametitle{Example state-based \CRDT}

    Grow-only set: replicated monotonic (supports $\cup$, but not $\setminus$)
    set, query $q$ defines a unary relation over items in the set.
    \[
      \textsf{G-Set}_s(\mathcal{X}) = \left\{\begin{aligned}
        S &: \mathcal{P}(\mathcal{X})~\onslide<2->{\text{%
          \color{red}
          Each element in the latice is some subset of $\mathcal{X}$.
        }} \\
        s^0 &: \{ \} \\
        q &: \lambda x.\, x \in s \\
        u &: \lambda x.\, s \cup \{ x \}~\onslide<2->{\text{%
          \color{red}
          The set is updated by replacing the current set with the union.
        }} \\
        m &: \lambda s_1, s_2.\, s_1 \cup s_2~\onslide<3->{\text{%
          \color{red}
          The union of sets defines a least-upper bound in the lattice.
        }} \\
      \end{aligned}\right.
    \]

    \pause

    The lattice-of-sets (for some family of items $\mathcal{X}$) is
    $\langle \mathcal{P}(\mathcal{X}), \subseteq \rangle$, and the least-upper
    bound is defined by $\cup$.
  \end{frame}

  \subsection{op-based \CRDTs}
  \begin{frame}
    \frametitle{op-based \CRDTs}

    An op-based \CRDT is a $6$-tuple $(S, s^0, q, t, u, P)$.

    \begin{itemize}[<+->]
      \item $S$, $s^0$, and $q$ retain the same meaning as for the state-based
        \CRDTs.
      \item $S$ need not necessairly form a semi-lattice.
      \item Operations are communicated instead of state. To deliver an
        operation:
        \begin{enumerate}[<+->]
          \item The \textit{prepare-update} implementation $t$ is applied at the
            locally to prepare a representation of the operation.
          \item The \textit{effect-update} implementation $u$ is applied at the
            local and remote replicas if and only if the delivery precondition
            $P$ is met, causing the desired update to take effect.
        \end{enumerate}
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{Example op-based \CRDT}

    To illustrate the difference between state- and op-based \CRDTs, here the
    analogue to $\textsf{G-Set}_s$:
    \[
      \textsf{G-Set}_o(\mathcal{X}) = \left\{\begin{aligned}
        S &: \mathcal{P}(\mathcal{X}) \\
        s^0 &: \{ \} \\
        q &: \lambda x.\, x \in s \\
        t &: \lambda x.\, (\textsf{ins}, x)~\onslide<2->{\text{%
          \color{red}
          \emph{Representation} of the operation.
        }} \\
        u &: \lambda p.\, s \cup \{(\textsf{snd}~p)\}~\onslide<3->{\text{%
          \color{red}
          \emph{Application} of the operation.
        }} \\
        m &: \lambda s_1, s_2.\, s_1 \cup s_2 \\
      \end{aligned}\right.
    \]
  \end{frame}

  \begin{frame}
    \frametitle{Example op-based \CRDT}

    To illustrate the difference between state- and op-based \CRDTs, here the
    analogue to $\textsf{G-Counter}_s$:
    \begin{columns}
      \begin{column}{.5\textwidth}
        \onslide<1,3>{
          \[
            \textsf{G-Counter}_o' = \left\{\begin{aligned}
              S &: \mathbb{N}_0^{|\mathcal{I}|} \\
              s^0 &: [ 0, 0, \cdots, 0 ] \\
              q &: \lambda s.\, \sum_{i \in \mathcal{I}} s(i) \\
              t &: (\textsf{inc}, i) \\
              u &: \lambda s,p.\, s\{ i \mapsto s(i) + 1 \} \\
            \end{aligned}\right.
          \]
        }
      \end{column}
      \begin{column}{.5\textwidth}
        \onslide<2->{%
          \[
            \textsf{G-Counter}_o = \left\{\begin{aligned}
              S &: \mathbb{N}_0 \\
              s^0 &: 0 \\
              q &: \lambda s.\, s \\
              t &: \textsf{inc} \\
              u &: \lambda s,p.\, s + 1 \\
            \end{aligned}\right.
          \]
        }
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}
    \frametitle{op- and state-based trade-offs}
    \begin{itemize}[<+->]
      \item state-based \CRDTs are resilient to degenerate network behaviors,
        such as delaying, dropping, and reordering messages in transit, but
        suffer from large payload size
      \item op-based \CRDTs have relatively small payload size, but require that
        the network deliver messages at-most-once
    \end{itemize}
    \pause
    Is there a middle ground?
  \end{frame}

  \section{$\delta$-state \CRDTs}
  \begin{frame}
    \frametitle{$\delta$-state \CRDTs}
    Like state-based \CRDTs, a $\delta$-state \CRDT is a $5$-tuple: $(S, s^0, q,
    u^\delta, m^\delta)$~\citep{almedia18}.
    \begin{itemize}
      \item $u^\delta$ produces an \emph{$\delta$-mutation}, which is
        representative of the update.
      \item $m^\delta$ is capable of merging a state $s \in S$ with the
        $\delta$-mutation produced by $u^\delta$.
    \end{itemize}
    Goal: the size of a $\delta$ mutation should be smaller than the state.
  \end{frame}

  \begin{frame}
    \frametitle{Example $\delta$-state \CRDT}
    Recall the original state-based G-Set, and consider how it might be
    represented as a $\delta$-state \CRDT:

    \[
      \textsf{G-Set}_{\alt<1>{s}{\delta}}(\mathcal{X}) = \left\{\begin{aligned}
        S &: \mathcal{P}(\mathcal{X}) \\
        s^0 &: \{ \} \\
        q &: \lambda x.\, x \in s \\
        u^{\only<2->{\delta}} &: \lambda x.\, \only<1>{s \cup} \{ x \} \\
        m^{\only<2->{\delta}} &: \lambda s_1, s_2.\, s_1 \cup s_2 \\
      \end{aligned}\right.
    \]
    \pause
    \pause
    Observe that both $u : S \to S \to S$ and $u^\delta : S \to S \to S$.
    \begin{itemize}[<+(1)->]
      \item Standard requirement from~\citet{almedia18} (they let $S$ for the
        G-Counter be $S : \mathcal{I} \hookrightarrow \mathbb{N}$).
      \item Not a requirement in this work.
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{Example $\delta$-state \CRDT (G-Counter)}

    Let's consider the state- and $\delta$-state encodings of the G-Counter:
    \pause
    \[
      \textsf{G-Counter}_{\alt<1-2>{s}{\delta}} = \left\{\begin{aligned}
        S &: \mathbb{N}_0^{|\mathcal{I}|} \\
        s^0 &: \left[ 0, 0, \cdots, 0 \right] \\
        q &: \lambda s.\, \sum_{i \in \mathcal{I}} s(i) \\
        u^{\only<3>{\delta}} &: \lambda s,i.\, \only<1-2>{s}\left\{ i \mapsto s(i) + 1 \right\} \\
        m^{\only<3>{\delta}} &: \lambda s_1, s_2.\, \left\{ \max\left\{ s_1(i), s_2(i) \right\}: i \in \mathsf{dom}(s_1) \cup
        \mathsf{dom}(s_2) \right\}
      \end{aligned}\right.
    \]
    \pause
    \text{\color{red}
      Use the notation $\{ i \mapsto x \}$ to encode an \emph{update} (index,
      new value) in the vector.
    }
  \end{frame}

  \begin{frame}
    \frametitle{\SEC \& $\delta$-\CRDTs?}

    \begin{enumerate}[<+->]
      \item We have a ``best-of-both-worlds'' \CRDT: the $\delta$-state \CRDT.
      \item Small update payload (more like $\mathcal{O}(\text{size of update})$
        instead of $\mathcal{O}(|\mathcal{I}|)$).
      \item $m^\delta$ is still elegant: commutative, associative, and
        idempotent $\Rightarrow$ weak network requirements (opposed to op-based
        \CRDTs).
    \end{enumerate}

    \pause
    Big question: does it satisfy SEC?
  \end{frame}

  \begin{frame}
    \frametitle{The rest of the talk}
    \begin{enumerate}[<+->]
      \item Answer the question of ``do $\delta$-state \CRDTs achieve \SEC?'' in
        the affirmative, with a mechanically checked proof.
      \item Build our proofs on the work of~\citet{gomes17}, verification
        library in Isabelle/HOL for op-based \CRDTs.
      \item State two reductions for viewing state- and $\delta$-state based
        \CRDTs as op-based.
      \item Overview of our proofs.
      \item Future directions.
    \end{enumerate}
  \end{frame}

  \section{\CRDT reductions}
  \begin{frame}
    \frametitle{Reduction I: state- to op-based}

    We have a type mismatch: want to verify properties of $\delta$-state \CRDTs,
    but library is designed for verifying op-based \CRDTs.
    \begin{itemize}[<+(1)->]
      \item Design a reduction from $\delta$-state \CRDTs to op-based.
      \item Convince ourselves of its correctness.
      \item Encode $\delta$-state \CRDTs as op-based in Isabelle, write proofs
        over the \emph{encoded} \CRDTs.
    \end{itemize}
    \pause
    Two reductions: state- to op-based, then $\delta$- to op-based.
    \begin{itemize}[<+(1)->]
      \item Call these $\phi_{\text{state} \to \text{op}}$ and $\phi_{\delta
        \to \text{op}}$, respectively.
      \item First is a ``warm-up'' to illustrate the general shape of these
        reductions.
      \item Latter is the reduction we use in our proofs.
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{Reduction I: state- to op-based}
    Want a reduction of the following form:
    \[
      \phi_{\text{state} \to \text{op}} :
        \underbrace{(S, s^0, q, u, m)}_{\text{state-based \CRDTs}} \longrightarrow
        \underbrace{(S, s^0, q, t, u, P)}_{\text{op-based \CRDTs}}
    \]
    \pause
    Simple idea:
    \begin{itemize}[<+->]
      \item Let state (specifically: $S, s^0, q$) be identical under the
        reduction.\footnote{Can often be more clever than this (for eg.,
        op-based G-Counter, but simplifies the reduction.)}
      \item Let $t$ return the result of (the state-based) $u$.
      \item Let $u$ perform as (the state-based) $m$.
      \item Let $P$ be always enabled.
    \end{itemize}
    \pause
    That is: let the op-based reduction of a state-based \CRDT the \CRDT which
    applies updates by performing a state-based merge.
  \end{frame}

  \begin{frame}
    \frametitle{Reduction I: state- to op-based}
    \begin{maxim}
      A state-based \CRDT is an op-based \CRDT where the \emph{prepare-update}
      phase returns the updated state, and the \emph{effect-update} is a join of
      two states.
    \end{maxim}
  \end{frame}

  \begin{frame}
    \frametitle{Reduction I: state- to op-based}
    Abstract conversion from a state- to op-based \CRDT under $\phi$:
    \[
      C_0 = \left\{ \begin{aligned}
        S_o &: \alert<2>{S} \\
        s^0_o &: \alert<2>{s^0} \\
        q_o &: \alert<2>{q} \\
        t_o &: \alert<3>{\lambda p.\, u(p...)} \\
        u_o &: \alert<4>{\lambda s_2.\, m(s^t, s_2)} \\
      \end{aligned} \right.
    \]
    \pause
  \end{frame}

  \begin{frame}
    \frametitle{Reduction II: $\delta$- to op-based}
    Want a reduction of the following form:
    \[
      \phi_{\delta \to \text{op}} :
        \underbrace{(S, s^0, q, u^\delta, m^\delta)}_{\text{$\delta$-based \CRDTs}}
        \longrightarrow
        \underbrace{(S, s^0, q, t, u, P)}_{\text{op-based \CRDTs}}
    \]
    \pause
    General idea:
    \begin{itemize}[<+->]
      \item Let $S$ be the type of each state and $T$ be the type of the
        $\delta$-fragments.
      \item Let $t : S \to S \to T$ act like the \emph{difference} between
        successive states.
      \item Let $u : S \to T \to S$ act like the pseudo-inverse of $t$ which
        ``unwinds'' the state.
      \item Let $P$ be always enabled.
    \end{itemize}
    \pause
    That is: let the op-based reduction of a $\delta$-state \CRDT be the \CRDT
    which applies updates over the \emph{$\delta$-fragments} of a state.
  \end{frame}

  \begin{frame}
    \frametitle{Reduction II: $\delta$- to op-based}
    \begin{maxim}
      A $\delta$-state based \CRDT is an op-based \CRDT whose messages are
      $\delta$-fragments, and whose operation is a pseudo-join between the
      current state and the $\delta$ fragment.
    \end{maxim}
  \end{frame}

  \begin{frame}
    \frametitle{Reduction II: $\delta$- to op-based}

    Example: apply $\phi_{\delta \to \text{op}}$ to the $\delta$-state G-Set.

    Two questions:
    \begin{enumerate}[<+(1)->]
      \item What is the $\delta$-fragement between two successive states
        $\Rightarrow$ what is $t$?
      \item How to ``join'' a $\delta$-fragment with our current state
        $\Rightarrow$ what is $u$?
    \end{enumerate}
    Two answers:
    \begin{enumerate}[<+->]
      \item Set difference.
      \item Set union.
    \end{enumerate}
  \end{frame}

  \begin{frame}
    \frametitle{Reduction II: $\delta$- to op-based}

    Let's consider how $\phi_{\delta\to\text{op}}$ behaves on the G-Set \CRDT:
    \pause
    \[
      \phi_{\delta\to\text{op}}(\textsf{G-Set}(\mathcal{X})) =
      \left\{ \begin{aligned}
        S &: \alert<2>{\mathcal{P}(\mathcal{X})} \\
        s^0 &: \alert<2>{\{ \}} \\
        q &: \alert<2>{\lambda x.\, x \in s} \\
        t &: \alert<3>{\lambda s_1, s_2.\, s_2 \setminus s_1} \\
        u &: \alert<4>{\lambda s_2.\, s \cup s_2} \\
      \end{aligned} \right.
    \]
    \onslide<5>{%
      Example of reducing a $\delta$-state \CRDT to an op-based one where the
      type of the state \emph{and} $\delta$-fragment are the same (ie., $S = T =
      \mathcal{P}(\mathcal{X})$).
    }
  \end{frame}

  \begin{frame}
    \frametitle{Reduction II: $\delta$- to op-based}

    Let's consider how $\phi_{\delta\to\text{op}}$ behaves on the G-Counter \CRDT:
    \pause
    \[
      \phi_{\delta\to\text{op}}(\textsf{G-Counter}) =
      \left\{ \begin{aligned}
        S &: \alert<2>{\mathbb{N}_0^{|\mathcal{I}|}} \\
        s^0 &: \alert<2>{[0, 0, \cdots, 0j]} \\
        q &: \alert<2>{\lambda.\, \sum_{i \in \mathcal{I}} s(i)} \\
        t &: \alert<3>{%
          \min_{\substack{i \in \mathcal{I} \\ s_1[i] \ne
            s_2[i]}} (i, s_2[i])} \\
        u &: \alert<4>{\lambda s, t.\, s\{ (\fst~t) \mapsto (\snd~t) \}} \\
      \end{aligned} \right.
    \]
    \onslide<5>{%
      Example of reducing a $\delta$-state \CRDT to an op-based one where the
      type of the state \emph{and} $\delta$-fragment are the same (ie., $S = T =
      \mathcal{P}(\mathcal{X})$).
    }
  \end{frame}

  \section{Mechanized \CRDT proofs}
  \begin{frame}
    \frametitle{Network relaxation}
  \end{frame}

  \begin{frame}
    \frametitle{State-based G-Counter}
  \end{frame}

  \begin{frame}
    \frametitle{State-based G-Set}
  \end{frame}

  \begin{frame}
    \frametitle{$\delta$-state G-Counter}
  \end{frame}

  \begin{frame}
    \frametitle{$\delta$-state G-Set}
  \end{frame}

  \section{Conclusion}
  \begin{frame}
    \frametitle{Future work}
    \begin{enumerate}[<+->]
      \item Pair type locales; parameterize a proof that combinations of \CRDTs
        are \SEC.
        \begin{enumerate}[<+->]
          \item Immediately: PN-Counter.
          \item Immediately: 2P-Set.
        \end{enumerate}
      \item Pure $\delta$-state encodings.
        \begin{enumerate}[<+->]
          \item Anti-entropy algorithms~\citep{almedia18}.
          \item No delivery precondition.
        \end{enumerate}
      \item Proofs of causally consistent $\delta$-state
        \CRDTs~\citep{almedia18}:
        \begin{enumerate}[<+->]
          \item \emph{$\delta$-interval}:
            \[
              \Delta^{a,b}_i = \bigsqcup \left\{ d_i^k : k \in [a, b) \right\}
            \]
          \item Causal merging condition: Replica $i$ only joins a
            $\delta$-interval $\Delta^{a,b}_j$ into its own state $X_i$ if: $X_i
            \sqsupseteq X_j^a$
        \end{enumerate}
    \end{enumerate}
  \end{frame}

  \begin{frame}
    \frametitle{Conclusion}

    \begin{enumerate}[<+->]
      \item Extended the work of~\citet{gomes17} to mechanize that
        $\delta$-state \CRDTs~\citep{almedia18} are \SEC.
      \item Two reductions: $\phi_{\text{state}\to\text{op}}$ and
        $\phi_{\delta\to\text{op}}$.
      \item Network relaxations to allow duplication of messages.
      \item Mechanized proof that two $\delta$-state \CRDTs (G-Counter, G-Set)
        are \SEC.
    \end{enumerate}
  \end{frame}

  \begin{frame}
    \centering
    \huge{Thank you!}

    \pause
    Questions?
  \end{frame}

  \begin{frame}[allowframebreaks]
    \bibliographystyle{abbrvnat}
    \bibliography{../../thesis.bib}
  \end{frame}
\end{document}
