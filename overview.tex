\chapter{Overview}
\label{chap:overview}

This chapter outlines the specific research goals we have in verifying Strong
Eventual Consistency in $\delta$-state \CRDTs. We will describe our efforts
building on top of the op-based \CRDT verification framework from Gomes et.
al~\citep{gomes17}. In addition, we'll discuss the unique way in which we view
op-, state-, and $\delta$-state \CRDTs in order to minimize the number of
modifications we were required to make in order to write proofs for
$\delta$-state \CRDTs on top of a framework originally designed for op-based
\CRDTs. Finally, we will motivate a series of changes that we made to the
existing network delivery semantics to strengthen our overall result.

\section{op-based \CRDTs as state-based}
Our discussion begins by addressing the question of how we will use a library
built to verify op-based \CRDTs to verify $\delta$-state \CRDTs. Our approach is
to view the set of $\delta$-state \CRDTs as a refinement of the set of
state-based \CRDTs, which are themselves in turn a refinement of the set of
op-based \CRDTs. In other words, we view op-based \CRDTs as the \emph{most}
expressive of the three categories of \CRDTs that we have discussed so far.
Before discussing the latter correspondence, we'll first begin by relating op-
and state-based \CRDTs to one another.

Consider some state-based \CRDT $C = (S, s^0, q, u, m)$. This object $C$ has a
set of states $S$, an initial state $s^0$, along with functions for querying the
state ($q$), updating its state ($u$), and merging its state with the state of
some other object $(m)$. Our question is to define a mapping $\varphi$ as
follows:
\[
  \varphi_{\text{state} \to \text{op}} :
    \underbrace{(S, s^0, q, u, m)}_{\text{state-based \CRDTs}} \longrightarrow
    \underbrace{(S, s^0, q, t, u)}_{\text{op-based \CRDTs}}
\]
For our purposes, we view $\varphi_{\text{state} \to \text{op}}$ as a homomorphism
between state- and op-based \CRDTs. If we had such a structure-preserving
transformation, then we would be able to verify any state-based \CRDT of our
choosing using the framework from Gomes et. al. Without modification to the
framework. Suppose that such a homomorphism exists. Then, the process for
verifying a state-based \CRDT using the op-based framework might look something
like as follows:
\begin{enumerate}
  \item Take a state-based \CRDT, say $C_s$, of interest for verification.
  \item Convert the state-based \CRDT into an op-based one by computing:
    \[
      C_o = \varphi_{\text{state} \to \text{op}}(C_s)
    \]
  \item Use $C_o$ as input to the verification tool.
\end{enumerate}

We'll now turn to describing the details of $\varphi{\text{state} \to \text{op}}$,
which for convenience in this section, we'll abbreviate as simply
$\varphi$.\footnote{In the following section, we'll define a new homomorphism
between state- and $\delta$-state based \CRDTs, at which point we will
distinguish between the two mappings when it is unclear which is being referred
to.} To understand $\varphi$, we'll consider how it maps the state $S$ (along with
$s^0$ and $q$) separately from how it maps the update procedure $u$.

\subsection{Mapping states under $\varphi$}
Let us begin our discussion with a consideration to how $\varphi$ maps the state
$S$ from a state-based \CRDT to an op-based one. In practice, it would be
unrealistic to treat the state space of a state-based \CRDT as equal to that of
its op-based counter-part. Doing so would discard one of the key benefits of
op-based \CRDTs over state-based ones, which is that they are often able to
represent the same set of query-able states using simpler structures. For
example, state-based counters (such as the $\textsf{G-Counter}_s$ and
$\textsf{PN-Counter}_s$) often use a vector representation to represent the
number of ``increment'' operations at each node. In this case, the query
function is often represented as:
\[
  q = \lambda s.\, \sum_{i \in \mathcal{I}} s[i]
\]
where $S = \mathbb{N}^{|\mathcal{I}|}_+$, and $s_0$ is the all-zeros vector.
This representation accommodates a relatively weak set of delivery semantics
including dropping, reordering, and duplication of messages\footnote{This
representation is also resilient to reordering of messages (though this
restriction causes causal inconsistencies with respect to the state), but this
is uninteresting for the example at hand.}. Because the counted values are
non-decreasing (that is, $S$ is a lattice), we have that:
\begin{itemize}
  \item Dropped updates are eventually propagated through nodes that \emph{do}
    receive them and join them locally (thus propagating them out further from
    their own state), or else not considered at all since no nodes have received
    them (in which case the preconditions for Strong Eventual Consistency are
    not met).
  \item Delayed and reordered updates are resolved identically no matter in what
    order they are received because the pair-wise maximum of two vectors is
    commutative.
  \item Duplicated messages are resolved idempotently.
\end{itemize}
The size of this representation scales like $\mathcal{O}(|\mathcal{I}|)$, since
vector has the same number of entries as there are participants in the system.
We treat this linear scaling as a ``large'' state representation. Compare this
to an op-based representation of the same object (i.e., $\textsf{G-Counter}_o$),
which can represent its state using only $S = \mathbb{N}_+$, since updates are
guaranteed to be delivered at most once (duplicating messages would cause states
to appear which do not correspond to the number of times an update was performed
in actuality, because the duplicate delivery would be indistinguishable from the
case where two updates were performed).

So, for remainder of this chapter, we treat $\varphi$ as preserving the state
space, and initial state under mapping. Since the query function $q$ is defined
in terms of the state-space, $S$, we let $\varphi$ preserve the implementation of
$q$ under the mapping, too.

\subsection{Mapping updates under $\varphi$}
Now that we have mapped $S$, $s^0$, and $q$ under $\varphi$, we still need to
address the implementation of $u$ and $m$ under mapping. Our guiding principle
is the following theorem (which we state and discuss here, but have not
mechanized):
\begin{theorem}
  Let $C_s$ be a state-based \CRDT with $C_s = (S, s^0, q, u, m)$. Suppose that
  $C_o$ is an op-based \CRDT, which is defined as follows:
  \[
    C_0 = \left\{ \begin{aligned}
      S_o &: S \\
      s^0_o &: s^0 \\
      q_o &: q \\
      t_o &: \lambda p.\, u(p...) \\
      u_o &: \lambda s_2.\, m(s^t, s_2) \\
    \end{aligned} \right.
  \]
  then, $C_o$ and $C_s$ reach equivalent states given equivalent updates and
  delivery semantics.
\end{theorem}
\begin{proof}
By simulation. Since $s^0_o = s^0$, both objects begin in the same state. Since
$q_o = q$, if the state of $C_o$ and $C_s$ are equal, then $q_o$ will reflect as
much. Finally, and update is prepared locally by computing the updated
state-based representation. That update is applied both locally and at all
replicas by merging the prepared state into $C_o$'s own state, preserving the
equality.
\end{proof}

In other words, we decompose the \textit{update} function of a state-based \CRDT
into the \textit{prepare-update} and \textit{effect-update} functions of an
op-based \CRDT. Suppose that a set of parameters $p$ are used to invoke the
update function $u$ of a state-based \CRDT, i.e., that $u(p...)$ produces the
desired updated state. Then the \textit{prepare-update} returns a serialized
representation of $u(p...)$, which is to say that it returns the updated state.
The \textit{effect-update} implementation then takes that representation and
applies it by invoking the merge function $m$ with the effect representation and
its own state to produce the new state.

All of this is to say the first of two maxims: a state-based \CRDT is an op-based
\CRDT where the operation is \emph{merge}.

\section{$\delta$-state based \CRDTs as state-based}
Now that we have a procedure for representing a state-based \CRDT as an
equivalent op-based \CRDT under the mapping $\varphi$, we only need to discover a
similar such mapping from a $\delta$-state to state-based \CRDT. Suppose that one
exists, and call it $\varphi_{\delta \to \text{state}}$. Then, we could compose
the two and obtain:
\[
  \varphi_{\delta \to \text{op}} =
    \varphi_{\text{state} \to \text{op}} \circ
    \varphi_{\delta \to \text{state}}
\]
Luckily, the mapping $\varphi_{\delta \to \text{state}}$ (which we now refer to
as $\varphi$ out of convenience, disambiguating where necessary) is identity.
This brings us to the second of the two maxims: all $\delta$-state \CRDTs are
themselves state-\CRDTs.

This is a crucial property of $\delta$-state \CRDTs that we reason about now. Any
$\delta$-state \CRDT has a state-space which describes a lattice, just like
state-based \CRDTs. Likewise, they have query, update, and merge functions. The
only difference between state- and $\delta$-state \CRDTs is that the
\emph{communicated} state is a \emph{fragment} of the overall state. Crucially,
these fragments are themselves part of the lattice $S$, which makes them
suitable for sending around and reasoning about as identically to state-based
\CRDTs.

Therefore, we have a straightforward procedure for reasoning about
$\delta$-state \CRDTs in terms of op-based \CRDTs, which is the following:
\begin{enumerate}
  \item Convert a $\delta$-state \CRDT into a state-based \CRDT by applying
    $\varphi_{\delta \to \text{state}}$.
  \item Convert that state-based \CRDT into an op-based \CRDT by applying
    $\varphi_{\text{state} \to \text{op}}$.
  \item Reason about the resulting op-based \CRDT using the existing framework
    and implementation.
\end{enumerate}

\section{Network Relaxations}
In our work, it was clear that the provided network model was not flexible
enough to support an interesting result that state- or $\delta$-state
\CRDTs achieve strong eventual consistency. Specifically, our concern was that
the provided network model did not support non-unique message identifiers, i.e.,
that messages in the network execution could not be duplicated. This is a key
requirement of op-based \CRDTs, where the operation contained in a message
delivery is \textit{non-idempotent}, and so at-most-once delivery is a
requirement for the object to achieve strong eventual consistency.

For example, consider a op-based counter, specified as follows \TODO[well-typed?]:
\[
\mathsf{GCounter}
  : \mathbb{I} \hookrightarrow \mathbb{N}
  = \left\{
      \begin{aligned}
        \bot &= \{\} \\
        \mathsf{op}_i(m) &= \{ i \mapsto 1 \} \\
        \mathsf{value}(m) &= \sum_{j \in \mathbb{I}} m(j) \\
        \mathsf{apply}(\mathsf{op}, m) &= \{
          m(j) + i : (j, i) \in \mathsf{op}
        \} \cup \{ j : j \in m \land j \notin \mathsf{op} \}
      \end{aligned}
    \right.
\]
The op-based GCounter in the above specification holds a vector that provides a
partial mapping between nodes in the system (for which we refer to the set of
identifiers as $\mathbb{I}$) and their value. If a mapping is missing for some
$i \in \mathbb{I}$, we assume that $i \mapsto 0$.

When the counter increments a value $i \in \mathbb{I}$ on $m$,
$\mathsf{op}_i(m)$ yields the serialized operation instructing the recipient
\CRDT to increment the value of $i$ by one. This is shown in the definition of
$\mathsf{apply}$, where the new state is comprised of the old state, where each
node identifier $j$ is incremented by $i$ (where $i$ is the number of increment
operations that $j$ has received, and $0$ if it has not been called).

This presents a problem for instantiations of the op-based GCounter in network
environments where messages delivered over that network are not known to have
unique identifiers. In other words, this presents a problem for op-based
GCounters in networks that can duplicate messages sent over that network.

We first present an example of an execution in an unreliable network for which
the op-based GCounter fails to achieve consistency:
\begin{example}
  Consider an execution amongst at least two op-based GCounters in a network
  which is able to duplicate messages. Suppose that the following happens, in
  this order:
  \begin{enumerate}
    \item One op-based GCounter receives an $\mathsf{op}_i(m)$ for some $i$.
    \item That counter applies the operation locally, taking $i \mapsto 1$. Then,
      the counter broadcasts the operation over the network, so that replicas may
      apply the same operation to their own state.
    \item The network duplicates that message, at least once.
    \item Other replicas receive more than one copy of the operation, mapping
      \textit{their} value of $i \mapsto v$ for $v \ge 1$.
  \end{enumerate}
  This is a trivial example of the non-idempotency of op-based \CRDT instances
  requiring at-most-once delivery semantics of the network in which they are
  instantiated.
\end{example}

State-based \CRDTs, however, do not require at-most-once semantics in order to
achieve strong eventual consistency. This follows from the requirement that a
state-based \CRDT's $\sqcup$ (read: \textit{join} or \textit{meet}) operation be
idempotent. To illustrate this remark, consider the above example, this time
using instead the state-based variant of the GCounter, as described
in~\citep{almedia18}.

\begin{example}
  Suppose that we use a state-based GCounter, given as follows (as originally
  described in~\citep{almedia18}):
  \[
    \mathsf{GCounter}
      : \mathbb{I} \hookrightarrow \mathbb{N}
      = \left\{
          \begin{aligned}
            \bot &= \{\} \\
            \mathsf{inc}_i(m) &= m\{ i \mapsto m(i) + 1 \} \\
            \mathsf{value}(m) &= \sum_{j \in \mathbb{I}} m(j) \\
            m \sqcup m' &= \{
              j \mapsto \max(m(j), m'(j)) :
              j \in \mathrm{dom}~m \cup \mathrm{dom}~m'
            \}
          \end{aligned}
        \right.
  \]

  Then, in a deployment of at least two state-based GCounters in a network that
  can duplicate messages, the state of each counter evolves as follows:
  \begin{enumerate}
    \item One state-based GCounter receives an $\mathsf{inc}_i(m)$ for some $i$.
      Then, each counter is left in the following state:
      \[
        m_1 = \{ i \mapsto 1 \},\quad
        m_2 = \bot
      \]
    \item Replica $m_1$ sends its state over the network, and $m_2$ applies it
      locally:
      \[
        m_1 = \{ i \mapsto 1 \},\quad
        m_2 = \{\} \sqcup m_1 = m_1
      \]
    \item The network duplicates $m_1$'s state from the previous step of the
      execution, and $m_2$ applies it again according to the rules of $\sqcup$:
      \[
        \begin{aligned}
          m_1 = \{ i \mapsto 1 \},\quad
          m_2
            &= \{ i \mapsto 1 \} \sqcup \{ i \mapsto 1 \} \\
            &= \{ i \mapsto \max(1, 1) \} \\
            &= \{ i \mapsto 1 \} = m_1 = m_2 \\
        \end{aligned}
      \]
  \end{enumerate}
\end{example}

The above example illustrates a general principle, which is the following:
\begin{theorem} \label{thm:state-sec-dup}
  State-based \CRDTs exhibit strong eventual consistency when operating in a
  network environment with non-unique messages.
\end{theorem}
\begin{proof}
  By induction on the number of times $i$ a message $m'$ is received. When $i =
  1$, the goal is trivially established. When $i > 1$, the idempotency of
  $\sqcup$ shows that:
  \[
    m \sqcup \underbrace{m' \sqcup \cdots \sqcup m'}_{\text{$i-1$ times}} \sqcup~m'
      = m \sqcup m' \sqcup m'
      = m \sqcup m'
  \]
  where the second equality follows from the inductive hypothesis, and the third
  from the fact that $m' \sqcup m' = m'$ by the idempotency of $\sqcup$.
\end{proof}

This result guides our approach as follows: to show a stronger result that uses
Theorem~\ref{thm:state-sec-dup} (i.e., that state- and $\delta$-state based
\CRDTs achieve strong eventual consistency no matter how many times), the network
model originally presented in~\citep{gomes17} should be extended to remove the
assumption that message identifiers are unique.

\subsection{Delivery Semantics}
In their original network model, the authors of~\citep{gomes17} use an Isabelle
\textit{locale} in order to parameterize varying instantiations of the network
based on certain assumptions. They provide the following definition for the
Network locale~\citep{gomes17}:
\begin{figure}[H]
\begin{isabelle}
~~~~~~~~\isakeyword{and}\ \=msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \={\isasymrbrakk}\ \={\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \=\kill
\isacommand{locale}\ network\ {\isacharequal}\ node{\isacharunderscore}histories\ history\\
~~~~\isakeyword{for}\>history\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}msg\ event\ list{\isachardoublequoteclose}\ {\isacharplus}\\
~~~~\isakeyword{fixes}\>msg{\isacharunderscore}id\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}msg\ {\isasymRightarrow}\ {\isacharprime}msgid{\isachardoublequoteclose}\\
~~~~\isakeyword{assumes}\ delivery{\isacharunderscore}has{\isacharunderscore}a{\isacharunderscore}cause{\isacharcolon}\\
\>\>{\isasymlbrakk}\ {\isachardoublequoteopen}Deliver\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>\>{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isasymexists}j{\isachardot}\ Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright}{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>deliver{\isacharunderscore}locally{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\  Broadcast\ m\ {\isasymsqsubset}\isactrlsup i\ Deliver\ m{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m{\isadigit{1}}\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright};\\
\>\>\>Broadcast\ m{\isadigit{2}}\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright};\\
\>\>\>msg{\isacharunderscore}id\ m{\isadigit{1}}\ {\isacharequal}\ msg{\isacharunderscore}id\ m{\isadigit{2}}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\ i\ {\isacharequal}\ j\ {\isasymand}\ m{\isadigit{1}}\ {\isacharequal}\ m{\isadigit{2}}{\isachardoublequoteclose}
\end{isabelle}
\centering
\caption{Isabelle specification of the Network locale as given
  in~\citep{gomes17}.}
\end{figure}

In particular, we desire to remove the assumption
$msg{\isacharunderscore}id{\isacharunderscore}unique$, which states that for two
broadcast messages, $m_1$ and $m_2$ appearing in the set of received messages
for nodes $i$ and $j$, respectively, that if the $msg{\isacharunderscore}id$ of
$m_1$ and $m_2$ are the same, then in fact both $m_1$ and $m_2$ are the same,
and nodes $i$ and $j$ are the same. Said otherwise, every message has an
\emph{unique} identifier.

As stated earlier, in order to instantiate our state- and $\delta$-state \CRDTs
over a network environment in which the result of
Theorem~\ref{thm:state-sec-dup} will be tested, we must allow for two messages
to share the same message identifier. In other words, in order to reuse the
network model from~\citep{gomes17}, we must strengthen it in order to allow for
messages to be duplicated in ordinary executions of that network model.

For our purposes, we begin by specifying a strengthened Network locale as
follows:
\begin{isabelle}
~~~~~~~~\isakeyword{and}\ \=msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \={\isasymrbrakk}\ \={\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \=\kill
\isacommand{locale}\ network\ {\isacharequal}\ node{\isacharunderscore}histories\ history\\
~~~~\isakeyword{for}\>history\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}msg\ event\ list{\isachardoublequoteclose}\ {\isacharplus}\\
~~~~\isakeyword{fixes}\>msg{\isacharunderscore}id\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}msg\ {\isasymRightarrow}\ {\isacharprime}msgid{\isachardoublequoteclose}\\
~~~~\isakeyword{assumes}\ delivery{\isacharunderscore}has{\isacharunderscore}a{\isacharunderscore}cause{\isacharcolon}\\
\>\>{\isasymlbrakk}\ {\isachardoublequoteopen}Deliver\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>\>{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isasymexists}j{\isachardot}\ Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright}{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>deliver{\isacharunderscore}locally{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\  Broadcast\ m\ {\isasymsqsubset}\isactrlsup i\ Deliver\ m{\isachardoublequoteclose}\\
\end{isabelle}

Immediately, many of the proofs related to the network model are no longer
valid. This can occur due to a trivial issue, such as referencing the removed
assumption in a simplification step, or a more complex matter, such as relying
on the message identifier uniqueness property in order to establish some goal.
We describe our approach for mending those broken proofs in order to reestablish
the locale's instantiation:
\begin{enumerate}
  \item Remove the assumption
    $msg{\isacharunderscore}id{\isacharunderscore}unique$ from the Network
    locale, as shown above.
  \item In any proof specified within that locale that mentions the
    aforementioned assumption remove it from tactic arguments.
  \item If the proof checks successfully without the additional tactic
    arguments, continue.
  \item Otherwise, end the proof with the $\isakeyword{sorry}$ keyword and
    continue.
\end{enumerate}
