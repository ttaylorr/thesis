\chapter{Overview}
This chapter describes our research goals, questions, and answers, as well as
outlines our methodology in answering those questions. Our overarching goal is
to show that several operation-based CRDT instances have suitable instantiations
as both state- and $\delta$-state-based CRDTs, and that all implementations
achieve strong eventual consistency. That is, that no matter what the CRDT type
is, the different instantiations still achieve the same overall state given that
they received the same set of messages over the network.

\section{Approach}
To accomplish the above goal, we extend the library presented originally by
Gomes et. al. in~\citep{gomes17}. In~\citep{gomes17}, the work was designed to
show that several instantiations of operation-based CRDTs achieve strong
eventual consistency. To that end, they provide a network and execution model,
as well as instantiations of a variety of CRDT objects. Specifically, they
instantiate the Observed-Remove Set (OR-set), the Replicated Growable Array
(RGA), and the Increment-Decrement Counter (PN-counter).

One of their research goals was to show that the desired convergence property
holds amongst these CRDT instances in all possible network executions. In other
words, their proofs take into account dropping and reordering of messages, so
that the convergence properties can be asserted in all network executions
regardless of the underlying network quality in a real-world deployment.

\subsection{Motivating Network Relaxations}
In our work, it was clear that the provided network model was not flexible
enough to support an interesting result that state- or $\delta$-state
CRDTs achieve strong eventual consistency. Specifically, our concern was that
the provided network model did not support non-unique message identifiers, i.e.,
that messages in the network execution could not be duplicated. This is a key
requirement of op-based CRDTs, where the operation contained in a message
delivery is \textit{non-idempotent}, and so at-most-once delivery is a
requirement for the object to achieve strong eventual consistency.

For example, consider a op-based counter, specified as follows \TODO[well-typed?]:
\[
\mathsf{GCounter}
  : \mathbb{I} \hookrightarrow \mathbb{N}
  = \left\{
      \begin{aligned}
        \bot &= \{\} \\
        \mathsf{op}_i(m) &= \{ i \mapsto 1 \} \\
        \mathsf{value}(m) &= \sum_{j \in \mathbb{I}} m(j) \\
        \mathsf{apply}(\mathsf{op}, m) &= \{
          m(j) + i : (j, i) \in \mathsf{op}
        \} \cup \{ j : j \in m \land j \notin \mathsf{op} \}
      \end{aligned}
    \right.
\]
The op-based GCounter in the above specification holds a vector that provides a
partial mapping between nodes in the system (for which we refer to the set of
identifiers as $\mathbb{I}$) and their value. If a mapping is missing for some
$i \in \mathbb{I}$, we assume that $i \mapsto 0$.

When the counter increments a value $i \in \mathbb{I}$ on $m$,
$\mathsf{op}_i(m)$ yields the serialized operation instructing the recipient
CRDT to increment the value of $i$ by one. This is shown in the definition of
$\mathsf{apply}$, where the new state is comprised of the old state, where each
node identifier $j$ is incremented by $i$ (where $i$ is the number of increment
operations that $j$ has received, and $0$ if it has not been called).

This presents a problem for instantiations of the op-based GCounter in network
environments where messages delivered over that network are not known to have
unique identifiers. In other words, this presents a problem for op-based
GCounters in networks that can duplicate messages sent over that network.

We first present an example of an execution in an unreliable network for which
the op-based GCounter fails to achieve consistency:
\begin{example}
  Consider an execution amongst at least two op-based GCounters in a network
  which is able to duplicate messages. Suppose that the following happens, in
  this order:
  \begin{enumerate}
    \item One op-based GCounter receives an $\mathsf{op}_i(m)$ for some $i$.
    \item That counter applies the operation locally, taking $i \mapsto 1$. Then,
      the counter broadcasts the operation over the network, so that replicas may
      apply the same operation to their own state.
    \item The network duplicates that message, at least once.
    \item Other replicas receive more than one copy of the operation, mapping
      \textit{their} value of $i \mapsto v$ for $v \ge 1$.
  \end{enumerate}
  This is a trivial example of the non-idempotency of op-based CRDT instances
  requiring at-most-once delivery semantics of the network in which they are
  instantiated.
\end{example}

State-based CRDTs, however, do not require at-most-once semantics in order to
achieve strong eventual consistency. This follows from the requirement that a
state-based CRDT's $\sqcup$ (read: \textit{join} or \textit{meet}) operation be
idempotent. To illustrate this remark, consider the above example, this time
using instead the state-based variant of the GCounter, as described
in~\citep{almedia18}.

\begin{example}
  Suppose that we use a state-based GCounter, given as follows (as originally
  described in~\citep{almedia18}):
  \[
    \mathsf{GCounter}
      : \mathbb{I} \hookrightarrow \mathbb{N}
      = \left\{
          \begin{aligned}
            \bot &= \{\} \\
            \mathsf{inc}_i(m) &= m\{ i \mapsto m(i) + 1 \} \\
            \mathsf{value}(m) &= \sum_{j \in \mathbb{I}} m(j) \\
            m \sqcup m' &= \{
              j \mapsto \max(m(j), m'(j)) :
              j \in \mathrm{dom}~m \cup \mathrm{dom}~m'
            \}
          \end{aligned}
        \right.
  \]

  Then, in a deployment of at least two state-based GCounters in a network that
  can duplicate messages, the state of each counter evolves as follows:
  \begin{enumerate}
    \item One state-based GCounter receives an $\mathsf{inc}_i(m)$ for some $i$.
      Then, each counter is left in the following state:
      \[
        m_1 = \{ i \mapsto 1 \},\quad
        m_2 = \bot
      \]
    \item Replica $m_1$ sends its state over the network, and $m_2$ applies it
      locally:
      \[
        m_1 = \{ i \mapsto 1 \},\quad
        m_2 = \{\} \sqcup m_1 = m_1
      \]
    \item The network duplicates $m_1$'s state from the previous step of the
      execution, and $m_2$ applies it again according to the rules of $\sqcup$:
      \[
        \begin{aligned}
          m_1 = \{ i \mapsto 1 \},\quad
          m_2
            &= \{ i \mapsto 1 \} \sqcup \{ i \mapsto 1 \} \\
            &= \{ i \mapsto \max(1, 1) \} \\
            &= \{ i \mapsto 1 \} = m_1 = m_2 \\
        \end{aligned}
      \]
  \end{enumerate}
\end{example}

The above example illustrates a general principle, which is the following:
\begin{theorem} \label{thm:state-sec-dup}
  State-based CRDTs exhibit strong eventual consistency when operating in a
  network environment with non-unique messages.
\end{theorem}
\begin{proof}
  By induction on the number of times $i$ a message $m'$ is received. When $i =
  1$, the goal is trivially established. When $i > 1$, the idempotency of
  $\sqcup$ shows that:
  \[
    m \sqcup \underbrace{m' \sqcup \cdots \sqcup m'}_{\text{$i-1$ times}} \sqcup~m'
      = m \sqcup m' \sqcup m'
      = m \sqcup m'
  \]
  where the second equality follows from the inductive hypothesis, and the third
  from the fact that $m' \sqcup m' = m'$ by the idempotency of $\sqcup$.
\end{proof}

This result guides our approach as follows: to show a stronger result that uses
Theorem~\ref{thm:state-sec-dup} (i.e., that state- and $\delta$-state based
CRDTs achieve strong eventual consistency no matter how many times), the network
model originally presented in~\citep{gomes17} should be extended to remove the
assumption that message identifiers are unique.

\subsection{Network Relaxations}
In their original network model, the authors of~\citep{gomes17} use an Isabelle
\textit{locale} in order to parameterize varying instantiations of the network
based on certain assumptions. They provide the following definition for the
Network locale~\citep{gomes17}:
\begin{figure}[H]
\begin{isabelle}
~~~~~~~~\isakeyword{and}\ \=msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \={\isasymrbrakk}\ \={\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \=\kill
\isacommand{locale}\ network\ {\isacharequal}\ node{\isacharunderscore}histories\ history\\
~~~~\isakeyword{for}\>history\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}msg\ event\ list{\isachardoublequoteclose}\ {\isacharplus}\\
~~~~\isakeyword{fixes}\>msg{\isacharunderscore}id\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}msg\ {\isasymRightarrow}\ {\isacharprime}msgid{\isachardoublequoteclose}\\
~~~~\isakeyword{assumes}\ delivery{\isacharunderscore}has{\isacharunderscore}a{\isacharunderscore}cause{\isacharcolon}\\
\>\>{\isasymlbrakk}\ {\isachardoublequoteopen}Deliver\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>\>{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isasymexists}j{\isachardot}\ Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright}{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>deliver{\isacharunderscore}locally{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\  Broadcast\ m\ {\isasymsqsubset}\isactrlsup i\ Deliver\ m{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m{\isadigit{1}}\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright};\\
\>\>\>Broadcast\ m{\isadigit{2}}\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright};\\
\>\>\>msg{\isacharunderscore}id\ m{\isadigit{1}}\ {\isacharequal}\ msg{\isacharunderscore}id\ m{\isadigit{2}}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\ i\ {\isacharequal}\ j\ {\isasymand}\ m{\isadigit{1}}\ {\isacharequal}\ m{\isadigit{2}}{\isachardoublequoteclose}
\end{isabelle}
\centering
\caption{Isabelle specification of the Network locale as given
  in~\citep{gomes17}.}
\end{figure}

In particular, we desire to remove the assumption
$msg{\isacharunderscore}id{\isacharunderscore}unique$, which states that for two
broadcast messages, $m_1$ and $m_2$ appearing in the set of received messages
for nodes $i$ and $j$, respectively, that if the $msg{\isacharunderscore}id$ of
$m_1$ and $m_2$ are the same, then in fact both $m_1$ and $m_2$ are the same,
and nodes $i$ and $j$ are the same. Said otherwise, every message has an
\emph{unique} identifier.

As stated earlier, in order to instantiate our state- and $\delta$-state CRDTs
over a network environment in which the result of
Theorem~\ref{thm:state-sec-dup} will be tested, we must allow for two messages
to share the same message identifier. In other words, in order to reuse the
network model from~\citep{gomes17}, we must strengthen it in order to allow for
messages to be duplicated in ordinary executions of that network model.

For our purposes, we begin by specifying a strengthened Network locale as
follows:
\begin{isabelle}
~~~~~~~~\isakeyword{and}\ \=msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \={\isasymrbrakk}\ \={\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \=\kill
\isacommand{locale}\ network\ {\isacharequal}\ node{\isacharunderscore}histories\ history\\
~~~~\isakeyword{for}\>history\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}msg\ event\ list{\isachardoublequoteclose}\ {\isacharplus}\\
~~~~\isakeyword{fixes}\>msg{\isacharunderscore}id\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}msg\ {\isasymRightarrow}\ {\isacharprime}msgid{\isachardoublequoteclose}\\
~~~~\isakeyword{assumes}\ delivery{\isacharunderscore}has{\isacharunderscore}a{\isacharunderscore}cause{\isacharcolon}\\
\>\>{\isasymlbrakk}\ {\isachardoublequoteopen}Deliver\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>\>{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isasymexists}j{\isachardot}\ Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright}{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>deliver{\isacharunderscore}locally{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\  Broadcast\ m\ {\isasymsqsubset}\isactrlsup i\ Deliver\ m{\isachardoublequoteclose}\\
\end{isabelle}

Immediately, many of the proofs related to the network model are no longer
valid. This can occur due to a trivial issue, such as referencing the removed
assumption in a simplification step, or a more complex matter, such as relying
on the message identifier uniqueness property in order to establish some goal.
We describe our approach for mending those broken proofs in order to reestablish
the locale's instantiation:
\begin{enumerate}
  \item Remove the assumption
    $msg{\isacharunderscore}id{\isacharunderscore}unique$ from the Network
    locale, as shown above.
  \item In any proof specified within that locale that mentions the
    aforementioned assumption remove it from tactic arguments.
  \item If the proof checks successfully without the additional tactic
    arguments, continue.
  \item Otherwise, end the proof with the $\isakeyword{sorry}$ keyword and
    continue.
\end{enumerate}

\TODO[explain proof strategy, describe modified proofs, claim network
strengthening, conclude section]

\subsection{op- \& state-based CRDTs}
\subsection{state- \& $\delta$-state CRDTs}
