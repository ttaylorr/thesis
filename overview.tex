\chapter{Overview}
\label{chap:overview}

This chapter outlines the specific research goals we have in verifying Strong
Eventual Consistency in $\delta$-state \CRDTs. Specifically, we will discuss the
following:
\begin{itemize}
  \item In Section~\ref{sec:state-as-op}, we will describe a mapping $\phi$ to
    view state-based \CRDTs in terms of their op-based counterparts.
  \item In Section~\ref{sec:delta-as-state}, we will note a key similarity
    between state- and $\delta$-state based \CRDTs. This intuition will allow us
    to use $\phi$ to reason about $\delta$-state \CRDTs in terms of op-based
    \CRDTs.
  \item Finally, in Section~\ref{sec:network-relaxations} we will motivate an
    area in which the underlying delivery semantics needed strengthening, and
    describe the manner in which we updated the relevant proofs.
\end{itemize}

In this section, we will identify and discuss the two key intuitions which guide
the remainder of our proof strategy. We'll refer to these intuitions as
``maxims''. They are stated here in brief, but we will return to them in
Sections~\ref{sec:state-as-op} and~\ref{sec:delta-as-state}.

\begin{maxim}
  \label{maxim:state-as-op}
  A state-based \CRDT is an op-based \CRDT where the \emph{prepare-update} phase
  returns the updated state, and the \emph{effect-update} is a join of two
  states.
\end{maxim}

\begin{maxim}
  \label{maxim:delta-as-state}
  A $\delta$-state based \CRDT is a state-based \CRDT which is allowed to send
  messages which do not reflect the entirety of its current state.
\end{maxim}

\section{state-based \CRDTs as op-based}
\label{sec:state-as-op}
Our discussion begins by addressing the question of how we will use a library
built to verify op-based \CRDTs to verify $\delta$-state \CRDTs. Our approach is
to view the set of $\delta$-state \CRDTs as a refinement of the set of
state-based \CRDTs, which are themselves in turn a refinement of the set of
op-based \CRDTs. In other words, we view op-based \CRDTs as the \emph{most}
expressive of the three categories of \CRDTs that we have discussed so far.
Before discussing the latter correspondence, we'll first begin by relating op-
and state-based \CRDTs to one another.

Consider some state-based \CRDT $C = (S, s^0, q, u, m)$. This object $C$ has a
set of states $S$, an initial state $s^0$, along with functions for querying the
state ($q$), updating its state ($u$), and merging its state with the state of
some other object $(m)$. Our question is to define a mapping $\phi$ as
follows:
\[
  \phi_{\text{state} \to \text{op}} :
    \underbrace{(S, s^0, q, u, m)}_{\text{state-based \CRDTs}} \longrightarrow
    \underbrace{(S, s^0, q, t, u)}_{\text{op-based \CRDTs}}
\]
For our purposes, we view $\phi_{\text{state} \to \text{op}}$ as a homomorphism
between state- and op-based \CRDTs. If we had such a structure-preserving
transformation, then we would be able to verify any state-based \CRDT of our
choosing using the framework from Gomes et. al. Without modification to the
framework. Then, the process for verifying a state-based \CRDT using the
op-based framework looks as follows:
\begin{enumerate}
  \item Take a state-based \CRDT, say $C_s$, of interest for verification.
  \item Convert the state-based \CRDT into an op-based one by computing:
    \[
      C_o = \phi_{\text{state} \to \text{op}}(C_s)
    \]
  \item Use $C_o$ as input to the verification tool.
\end{enumerate}

We'll now turn to describing the details of $\phi{\text{state} \to \text{op}}$,
which for convenience in this section, we'll abbreviate as simply
$\phi$.\footnote{In the following section, we'll define a new homomorphism
between state- and $\delta$-state based \CRDTs, at which point we will
distinguish between the two mappings when it is unclear which is being referred
to.} To understand $\phi$, we'll consider how it maps the state $S$ (along with
$s^0$ and $q$) separately from how it maps the update procedure $u$.

\subsection{Mapping states under $\phi$}
Let us begin our discussion with a consideration to how $\phi$ maps the state
$S$ from a state-based \CRDT to an op-based one. In practice, it would be
unrealistic to treat the state space of a state-based \CRDT as equal to that of
its op-based counter-part. Doing so would discard one of the key benefits of
op-based \CRDTs over state-based ones, which is that they are often able to
represent the same set of query-able states using simpler structures. For
example, state-based counters (such as the $\textsf{G-Counter}_s$ and
$\textsf{PN-Counter}_s$) often use a vector representation to represent the
number of ``increment'' operations at each node. In this case, the query
function is often represented as:
\[
  q = \lambda s.\, \sum_{i \in \mathcal{I}} s[i]
\]
where $S = \mathbb{N}^{|\mathcal{I}|}_+$, and $s_0$ is the all-zeros vector.
This representation accommodates a relatively weak set of delivery semantics
including dropping, reordering, and duplication of messages.\footnote{This
representation is also resilient to reordering of messages (though this
restriction causes causal inconsistencies with respect to the state), but this
is uninteresting for the example at hand.} Because the counted values are
non-decreasing (that is, $S$ is a lattice), we have that:
\begin{itemize}
  \item Dropped updates are eventually propagated through nodes that \emph{do}
    receive them and join them locally (thus propagating them out further from
    their own state), or else not considered at all since no nodes have received
    them (in which case the preconditions for Strong Eventual Consistency are
    not met).
  \item Delayed and reordered updates are resolved identically no matter in what
    order they are received because the pair-wise maximum of two vectors is
    commutative.
  \item Duplicated messages are resolved idempotently.
\end{itemize}
Since the vector has an entry for each participant in the system, it grows
as a linear function of the number of participants overall. Scaling linearly in
this fashion is indicative of a ``large'' state representation.\footnote{Partly
because \CRDTs are often composed with one another, e.g., as in the PN-Counter,
and so this linear factor contributes to \emph{each} of the composed \CRDTs,
increasing the size of the overall \CRDT even more.} Compare this to an op-based
representation of the same object (i.e., $\textsf{G-Counter}_o$), which can
represent its state using only $S = \mathbb{N}_+$, since updates are guaranteed
to be delivered at most once (duplicating messages would cause states to appear
which do not correspond to the number of times an update was performed in
actuality, because the duplicate delivery would be indistinguishable from the
case where two updates were performed).

So, for remainder of this chapter, we treat $\phi$ as preserving the state
space, and initial state under mapping. Since the query function $q$ is defined
in terms of the state-space, $S$, we let $\phi$ preserve the implementation of
$q$ under the mapping, too.

\subsection{Mapping updates under $\phi$}
Now that we have mapped $S$, $s^0$, and $q$ under $\phi$, we still need to
address the implementation of $u$ and $m$ under mapping. Our guiding principle
is the following theorem (which we state and discuss here, but have not
mechanized):
\begin{theorem}
  Let $C_s$ be a state-based \CRDT with $C_s = (S, s^0, q, u, m)$. Define an
  op-based \CRDT $C_o$ as follows:
  \[
    C_0 = \left\{ \begin{aligned}
      S_o &: S \\
      s^0_o &: s^0 \\
      q_o &: q \\
      t_o &: \lambda p.\, u(p...) \\
      u_o &: \lambda s_2.\, m(s^t, s_2) \\
    \end{aligned} \right.
  \]
  then, $C_o$ and $C_s$ reach equivalent states given equivalent updates and
  delivery semantics.
\end{theorem}
\begin{proof}
By simulation. Since $s^0_o = s^0$, both objects begin in the same state. Since
$q_o = q$, if the state of $C_o$ and $C_s$ are equal, then $q_o$ will reflect as
much. Finally, and update is prepared locally by computing the updated
state-based representation. That update is applied both locally and at all
replicas by merging the prepared state into $C_o$'s own state, preserving the
equality.
\end{proof}

In other words, we decompose the \textit{update} function of a state-based \CRDT
into the \textit{prepare-update} and \textit{effect-update} functions of an
op-based \CRDT. Let $p$ be the set of parameters used to invoke the update
function $u$ of a state-based \CRDT, i.e., that $u(p...)$ produces the desired
updated state. Then the \textit{prepare-update} returns a serialized
representation of $u(p...)$, which is to say that it returns the updated state.
The \textit{effect-update} implementation then takes that representation and
applies it by invoking the merge function $m$ with the effect representation and
its own state to produce the new state.

This introduces Maxim~\ref{maxim:state-as-op}, which unifies state- and op-based
\CRDTs as behaving identically when the op-based \CRDT performs a join of two
states. We restate this Maxim for clarity:

\setcounter{maxim}{0}
\begin{maxim}
  A state-based \CRDT is an op-based \CRDT where the \emph{prepare-update} phase
  returns the updated state, and the \emph{effect-update} is a join of two
  states.
\end{maxim}

\section{$\delta$-state based \CRDTs as state-based}
\label{sec:delta-as-state}
Now that we have a procedure for representing a state-based \CRDT as an
equivalent op-based \CRDT under the mapping $\phi$, we only need to discover a
similar such mapping from a $\delta$-state to state-based \CRDT.  Then,
composing the two allows us to obtain:
\[
  \phi_{\delta \to \text{op}} =
    \phi_{\text{state} \to \text{op}} \circ
    \phi_{\delta \to \text{state}}
\]
Luckily, the mapping $\phi_{\delta \to \text{state}}$ (which we now refer to
as $\phi$ out of convenience, disambiguating where necessary) is identity.
This brings us to Maxim~\ref{maxim:delta-as-state}, which we restate here for
clarity:

\setcounter{maxim}{1}
\begin{maxim}
  A $\delta$-state based \CRDT is a state-based \CRDT which is allowed to send
  messages which do not reflect the entirety of its current state.
\end{maxim}

This is a crucial property of $\delta$-state \CRDTs that we reason about now. Any
$\delta$-state \CRDT has a state-space which describes a lattice, just like
state-based \CRDTs. Likewise, they have query, update, and merge functions. The
only difference between state- and $\delta$-state \CRDTs is that the
\emph{communicated} state is a \emph{fragment} of the overall state. Crucially,
these fragments are themselves part of the lattice $S$, which makes them
suitable for sending around and reasoning about as identically to state-based
\CRDTs.

Therefore, we have a straightforward procedure for reasoning about
$\delta$-state \CRDTs in terms of op-based \CRDTs, which is the following:
\begin{enumerate}
  \item Convert a $\delta$-state \CRDT into a state-based \CRDT by applying
    $\phi_{\delta \to \text{state}}$.
  \item Convert that state-based \CRDT into an op-based \CRDT by applying
    $\phi_{\text{state} \to \text{op}}$.
  \item Reason about the resulting op-based \CRDT using the existing framework
    and implementation.
\end{enumerate}

\section{Network Relaxations}
\label{sec:network-relaxations}
In~\citep{gomes17}, Gomes and his co-authors provided a network model which
makes the following set of assumptions:
\begin{enumerate}
  \item All messages received by some node were broadcast by some other node.
  \item All messages broadcasted by some node were received by that node (i.e.,
    all messages are delivered locally in a reliable fashion).
  \item All messages are unique.
\end{enumerate}
These assumptions allow the network to drop, reorder, and delay messages in
transit.

Because op-based \CRDTs only deliver updates once, it is traditional to assume a
delivery relation $P$ which predicates the set of network executions that we are
allowed to reason about. For example, a network execution which drops all
messages in transit, or does not preserve causality cannot be shown to exhibit
\SEC, and so it is not a member of the relation $P$.  Such an assumption is
standard in the literature and goes back to the original work
in~\citep{shapiro11}.

In~\citep{gomes17}, the authors specify that the following assumptions must be
met in order to instantiate their
$\isa{strong}\isacharunderscore\isa{eventual}\isacharunderscore\isa{consistency}$
locale--for our purposes we can think of this as the set of preconditions on the
relation $P$:
\begin{itemize}
  \item Messages which have a causal dependence are delivered in-order;
    concurrent messages may be delivered in any order (i.e., the $\prec$
    relation is preserved during delivery).
  \item The set of messages delivered at each node is distinct.\footnote{Note
    that the messages transited by the network may be non-distinct. This is
    another standard assumption~\citep{} which can be implemented by tagging
    each message with a vector clock or assigning a globally unique identifier,
    and having each receiving node discard duplicates.}
  \item That concurrent operations commute.
  \item That correct nodes do not fail, i.e., that they remain responsive during
    the execution.
\end{itemize}

While we consider the above to be a reasonable delivery semantics, we wish to
strengthen the network model in order to support duplicated messages. This
behavior is not permitted by the original network model in~\citep{gomes17},
which assumes that each message in transit on the network has a unique
identifier.

To see this, consider the following example:

\begin{example}
  \label{example:state-op-dup-msgs}
  Consider two systems which have multiple replicas of \CRDT counters. System
  $A$ uses op-based counters, and system $B$ uses state-based counters. Consider
  two replicas in each system, call these $r_1$ and $r_2$. Suppose the following
  happens in each system:

  \begin{itemize}
    \item A \textsf{inc} operation is performed at replica $r_1$, which causes a
      message to be sent to all other replicas. In system $A$, this message is
      $[1, 0, \cdots, 0]$, and in system $B$ this messages is $\textsf{inc}$.
    \item While in route to replica $r_2$, this message is duplicated, and both
      copies are received at replica $r_2$.
  \end{itemize}

  Notice that $q(r_2)$ results in a different value based on whether or not you
  queried the replica belonging to system $A$ or system $B$. In system $A$, the
  duplicate message is ``ignored'', since merging the same message twice is
  idempotent due to $\sqcup$, and $q(r_2) = 1$ as expected. In system $B$, the
  additional update \emph{is} applied, meaning that $q(r_2) = 2$, which is a
  safety violation.
\end{example}

So, while it is often a safety violation for an op-based \CRDT to receive the
same message twice\footnote{This is the primary reason why it is a standard
assumption of op-based network models to disallow non-unique messages},
state- and $\delta$-state based \CRDTs can and should tolerate this class of
degenerate behaviors.

The general principle is as follows:
\begin{theorem} \label{thm:state-sec-dup}
  State-based \CRDTs exhibit strong eventual consistency even when operating in
  a network environment permitting non-unique messages.
\end{theorem}
\begin{proof}
  By induction on the number of times $i$ a message $m'$ is received. When $i =
  1$, the goal is trivially established. When $i > 1$, the idempotency of
  $\sqcup$ shows that:
  \[
    m \sqcup \underbrace{m' \sqcup \cdots \sqcup m'}_{\text{$i-1$ times}} \sqcup~m'
      = m \sqcup m' \sqcup m'
      = m \sqcup m'
  \]
  where the second equality follows from the inductive hypothesis, and the third
  from the fact that $m' \sqcup m' = m'$ by the idempotency of $\sqcup$.
\end{proof}

This result guides our approach as follows: to show a stronger result that uses
Theorem~\ref{thm:state-sec-dup} (i.e., that state- and $\delta$-state based
\CRDTs achieve strong eventual consistency no matter how many times), the network
model originally presented in~\citep{gomes17} should be extended to remove the
assumption that message identifiers are unique.

\subsection{Delivery Semantics}
In their original network model, the authors of~\citep{gomes17} use an Isabelle
\textit{locale} in order to parameterize varying instantiations of the network
based on certain assumptions. They provide the following definition for the
Network locale~\citep{gomes17}:
\begin{figure}[H]
\begin{isabelle}
~~~~~~~~\isakeyword{and}\ \=msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \={\isasymrbrakk}\ \={\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \=\kill
\isacommand{locale}\ network\ {\isacharequal}\ node{\isacharunderscore}histories\ history\\
~~~~\isakeyword{for}\>history\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}msg\ event\ list{\isachardoublequoteclose}\ {\isacharplus}\\
~~~~\isakeyword{fixes}\>msg{\isacharunderscore}id\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}msg\ {\isasymRightarrow}\ {\isacharprime}msgid{\isachardoublequoteclose}\\
~~~~\isakeyword{assumes}\ delivery{\isacharunderscore}has{\isacharunderscore}a{\isacharunderscore}cause{\isacharcolon}\\
\>\>{\isasymlbrakk}\ {\isachardoublequoteopen}Deliver\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>\>{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isasymexists}j{\isachardot}\ Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright}{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>deliver{\isacharunderscore}locally{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\  Broadcast\ m\ {\isasymsqsubset}\isactrlsup i\ Deliver\ m{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m{\isadigit{1}}\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright};\\
\>\>\>Broadcast\ m{\isadigit{2}}\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright};\\
\>\>\>msg{\isacharunderscore}id\ m{\isadigit{1}}\ {\isacharequal}\ msg{\isacharunderscore}id\ m{\isadigit{2}}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\ i\ {\isacharequal}\ j\ {\isasymand}\ m{\isadigit{1}}\ {\isacharequal}\ m{\isadigit{2}}{\isachardoublequoteclose}
\end{isabelle}
\centering
\caption{Isabelle specification of the Network locale as given
  in~\citep{gomes17}.}
\end{figure}

In order to extend the network model of Gomes et. al. to support duplicated
messages, we need to remove the assumption
$\isa{msg}\isacharunderscore\isa{id}\isacharunderscore\isa{unique}$, which
allows the enclosed proofs to assume that messages have unique identifiers.
While this assumption is part of the locale, proofs are allowed to assume that
if two messages $m_1$ and $m_2$ with the same identifier (i.e., that
$\isa{msg}\isacharunderscore\isa{id} m_1 = \isa{msg}\isacharunderscore\isa{id}
m_2$) exists in the history of two nodes, that either the two nodes or two
messages are identical.

Although our proofs are still instantiated after fulfilling the qualifier $P$,
we still wish to reason about an expanded set of network executions which
includes message dropping.\footnote{Since op-based \CRDTs require nice semantics
$P$, we cannot remove the dependence on $P$ without substantial alternation to
the library. We leave this to future work, and discuss it in greater detail in
Chapter~\ref{chap:future-work}.}

For our purposes, we begin by specifying a strengthened Network locale as
follows:
\begin{isabelle}
~~~~~~~~\isakeyword{and}\ \=msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \={\isasymrbrakk}\ \={\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \=\kill
\isacommand{locale}\ network\ {\isacharequal}\ node{\isacharunderscore}histories\ history\\
~~~~\isakeyword{for}\>history\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}msg\ event\ list{\isachardoublequoteclose}\ {\isacharplus}\\
~~~~\isakeyword{fixes}\>msg{\isacharunderscore}id\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}msg\ {\isasymRightarrow}\ {\isacharprime}msgid{\isachardoublequoteclose}\\
~~~~\isakeyword{assumes}\ delivery{\isacharunderscore}has{\isacharunderscore}a{\isacharunderscore}cause{\isacharcolon}\\
\>\>{\isasymlbrakk}\ {\isachardoublequoteopen}Deliver\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>\>{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isasymexists}j{\isachardot}\ Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright}{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>deliver{\isacharunderscore}locally{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\  Broadcast\ m\ {\isasymsqsubset}\isactrlsup i\ Deliver\ m{\isachardoublequoteclose}\\
\end{isabelle}

Removing this assumption immediately invalidates many of the proofs contained
within the $\isa{network}$ locale. These proofs are broken due to a variety of
reasons, ranging form something as simple as referencing a now-missing
assumption, to more complex issues, e.g., a proof which relies on the uniqueness
of delivered messages.

We now describe our strategy for repairing these proofs:
\begin{enumerate}
  \item First, remove the assumption
    $\isa{msg}\isacharunderscore\isa{id}\isacharunderscore\isa{unique}$ from the
    $\isa{network}\isacharunderscore\isa{with}\isacharunderscore\isa{ops}$
    locale, as above.
  \item Identify the set of broken proofs. In each broken proof, do the
    following:
    \begin{enumerate}
      \item Identify the earliest broken proof step.
      \item Delete it and all proof steps following it.
      \item Replace the proof body with the term $\isakeyword{sorry}$.
    \end{enumerate}
  \item In any order, consider a proof which ends with $\isakeyword{sorry}$, and
    repair the proof.
\end{enumerate}

In total, there were four (4) key lemmas which needed repair. These were:
$\isa{hb}\isacharunderscore\isa{antisym}$,
$\isa{hb}\isacharunderscore\isa{has}\isacharunderscore\isa{a}\isacharunderscore\isa{reason}$,
$\isa{hb}\isacharunderscore\isa{cross}\isacharunderscore\isa{node}\isacharunderscore\isa{delivery}$, and
$\isa{hb}\isacharunderscore\isa{broadcast}\isacharunderscore\isa{broadcast}\isacharunderscore\isa{order}$.
After removing the
$\isa{msg}\isacharunderscore\isa{id}\isacharunderscore\isa{unique}$ assumption,
each of the above four proofs were able to be repaired automatically by
Isabelle's proof search keyword $\isakeyword{sledgehammer}$~\citep{wenzel02}.

In each of the \CRDTs that we do verify, we are required to instantiate a lemma
stating:
\[
  \isa{apply}\isacharunderscore\isa{operations}~\isa{xs}~\isacharequal~
  \isa{apply}\isacharunderscore\isa{operations}~\isa{ys}
\]
where $\isa{xs}$ and $\isa{ys}$ are lists of messages delivered to a pair of
replicas by the network. In other words, no matter what messages are delivered
in what order, the two replicas attain the same state. Following the original
proofs provided for op-based \CRDTs in~\citep{gomes17}, our proofs of this lemma
make the standard assumption that:
\[
  \isakeyword{set}~(\isa{node}\isacharunderscore\isa{deliver}\isacharunderscore\isa{messages}~\isa{xs})~\isacharequal~
  \isakeyword{set}~(\isa{node}\isacharunderscore\isa{deliver}\isacharunderscore\isa{messages}~\isa{ys})
\]
Note that although we require that the set of operations delivered at two nodes
is identical in order for those two nodes to attain the same value, we are able
to reason over an expanded set of network behaviors. For example, if some
message $m$ appears in either of the two sets above, we know that it only
appears in that node's history once, by the
$\isa{msg}\isacharunderscore\isa{id}\isacharunderscore\isa{unique}$ assumption.
But without that assumption, we know instead that it appears \emph{at least}
once in each of the node's log of history.

This is a key distinction, since not knowing how many times a message was
delivered to either of the two replicas means that we are able to conclude that
they reach the same state if the same set of messages is delivered \emph{at
least once} to each of the replicas. Said otherwise, it does not matter how many
times a message was delivered at each of two replicas, so long as it was
delivered at least once at both. This allows us to exercise the latter case of
Example~\ref{example:state-op-dup-msgs} using the strengthened network model.
