\chapter{Example \CRDTs under Weak Network Model}
\label{chap:example-crdts}

In this chapter, we discuss our efforts mechanizing proofs that two state- and
$\delta$-state based \CRDTs achieve \SEC.  We discuss our efforts to weaken the
underlying network model to support non-unique messages, and then show that both
the state- and $\delta$-state based G-Counter and G-Set inhabit \SEC. Finally,
we discuss an alternative encoding of the reduction in
Chapter~\ref{chap:crdt-reductions} for $\delta$-state \CRDTs.

\section{Network Relaxations}
\label{sec:network-relaxations}
In~\citep{gomes17}, Gomes and his co-authors provided a network model which
makes the following set of assumptions:
\begin{enumerate}
  \item All messages received by some node were broadcast by some other node.
  \item All messages broadcast by some node were received by that node (i.e.,
    all messages are delivered locally in a reliable fashion).
  \item All messages are unique.
\end{enumerate}
These assumptions allow the network to drop, reorder, and delay messages in
transit.

Because op-based \CRDTs only deliver updates once, it is traditional to assume a
delivery relation $P$ which predicates the set of network executions that we are
allowed to reason about. For example, a network execution which drops all
messages in transit, or does not preserve causality cannot be shown to exhibit
\SEC, and so it is not a member of the relation $P$.  Such an assumption is
standard in the literature and goes back to the original work
in~\citep{shapiro11}.

In~\citep{gomes17}, the authors specify that the following assumptions must be
met in order to instantiate their
$\isa{strong}\isacharunderscore\isa{eventual}\isacharunderscore\isa{consistency}$
locale--for our purposes we can think of this as the set of preconditions on the
relation $P$:
\begin{itemize}
  \item Messages which have a causal dependence are delivered in-order;
    concurrent messages may be delivered in any order (i.e., the $\prec$
    relation is preserved during delivery).
  \item The set of messages delivered at each node is distinct.\footnote{Note
    that the messages transited by the network may be non-distinct. This is
    another standard assumption~\citep{} which can be implemented by tagging
    each message with a vector clock or assigning a globally unique identifier,
    and having each receiving node discard duplicates.}
  \item That concurrent operations commute.
  \item That correct nodes do not fail, i.e., that they remain responsive during
    the execution.
\end{itemize}

While we consider the above to be a reasonable delivery semantics, we wish to
strengthen the network model in order to support duplicated messages. This
behavior is not permitted by the original network model in~\citep{gomes17},
which assumes that each message in transit on the network has a unique
identifier.

To see this, consider the following example:

\begin{example}
  \label{example:state-op-dup-msgs}
  Consider two systems which have multiple replicas of \CRDT counters. System
  $A$ uses op-based counters, and system $B$ uses state-based counters. Consider
  two replicas in each system, call these $r_1$ and $r_2$. Suppose the following
  happens in each system:

  \begin{itemize}
    \item A \textsf{inc} operation is performed at replica $r_1$, which causes a
      message to be sent to all other replicas. In system $A$, this message is
      $[1, 0, \cdots, 0]$, and in system $B$ this messages is $\textsf{inc}$.
    \item While in route to replica $r_2$, this message is duplicated, and both
      copies are received at replica $r_2$.
  \end{itemize}

  Notice that $q(r_2)$ results in a different value based on whether or not you
  queried the replica belonging to system $A$ or system $B$. In system $A$, the
  duplicate message is ``ignored'', since merging the same message twice is
  idempotent due to $\sqcup$, and $q(r_2) = 1$ as expected. In system $B$, the
  additional update \emph{is} applied, meaning that $q(r_2) = 2$, which is a
  safety violation.
\end{example}

So, while it is often a safety violation for an op-based \CRDT to receive the
same message twice\footnote{This is the primary reason why it is a standard
assumption of op-based network models to disallow non-unique messages},
state- and $\delta$-state based \CRDTs can and should tolerate this class of
degenerate behaviors.

The general principle is as follows:
\begin{theorem} \label{thm:state-sec-dup}
  State-based \CRDTs exhibit strong eventual consistency even when operating in
  a network environment permitting non-unique messages.
\end{theorem}
\begin{proof}
  By induction on the number of times $i$ a message $m'$ is received. When $i =
  1$, the goal is trivially established. When $i > 1$, the idempotency of
  $\sqcup$ shows that:
  \[
    m \sqcup \underbrace{m' \sqcup \cdots \sqcup m'}_{\text{$i-1$ times}} \sqcup~m'
      = m \sqcup m' \sqcup m'
      = m \sqcup m'
  \]
  where the second equality follows from the inductive hypothesis, and the third
  from the fact that $m' \sqcup m' = m'$ by the idempotency of $\sqcup$.
\end{proof}

This result guides our approach as follows: to show a stronger result that uses
Theorem~\ref{thm:state-sec-dup} (i.e., that state- and $\delta$-state based
\CRDTs achieve strong eventual consistency no matter how many times), the network
model originally presented in~\citep{gomes17} should be extended to remove the
assumption that message identifiers are unique.

\subsection{Delivery Semantics}
In their original network model, the authors of~\citep{gomes17} use an Isabelle
\textit{locale} in order to parameterize varying instantiations of the network
based on certain assumptions. They provide the following definition for the
Network locale~\citep{gomes17}:
\begin{figure}[H]
\begin{isabelle}
~~~~~~~~\isakeyword{and}\ \=msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \={\isasymrbrakk}\ \={\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \=\kill
\isacommand{locale}\ network\ {\isacharequal}\ node{\isacharunderscore}histories\ history\\
~~~~\isakeyword{for}\>history\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}msg\ event\ list{\isachardoublequoteclose}\ {\isacharplus}\\
~~~~\isakeyword{fixes}\>msg{\isacharunderscore}id\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}msg\ {\isasymRightarrow}\ {\isacharprime}msgid{\isachardoublequoteclose}\\
~~~~\isakeyword{assumes}\ delivery{\isacharunderscore}has{\isacharunderscore}a{\isacharunderscore}cause{\isacharcolon}\\
\>\>{\isasymlbrakk}\ {\isachardoublequoteopen}Deliver\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>\>{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isasymexists}j{\isachardot}\ Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright}{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>deliver{\isacharunderscore}locally{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\  Broadcast\ m\ {\isasymsqsubset}\isactrlsup i\ Deliver\ m{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m{\isadigit{1}}\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright};\\
\>\>\>Broadcast\ m{\isadigit{2}}\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright};\\
\>\>\>msg{\isacharunderscore}id\ m{\isadigit{1}}\ {\isacharequal}\ msg{\isacharunderscore}id\ m{\isadigit{2}}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\ i\ {\isacharequal}\ j\ {\isasymand}\ m{\isadigit{1}}\ {\isacharequal}\ m{\isadigit{2}}{\isachardoublequoteclose}
\end{isabelle}
\centering
\caption{Isabelle specification of the Network locale as given
  in~\citep{gomes17}.}
\end{figure}

In order to extend the network model of Gomes et. al. to support duplicated
messages, we need to remove the assumption
$\isa{msg}\isacharunderscore\isa{id}\isacharunderscore\isa{unique}$, which
allows the enclosed proofs to assume that messages have unique identifiers.
While this assumption is part of the locale, proofs are allowed to assume that
if two messages $m_1$ and $m_2$ with the same identifier (i.e., that
$\isa{msg}\isacharunderscore\isa{id} m_1 = \isa{msg}\isacharunderscore\isa{id}
m_2$) exists in the history of two nodes, that either the two nodes or two
messages are identical.

Although our proofs are still instantiated after fulfilling the qualifier $P$,
we still wish to reason about an expanded set of network executions which
includes message dropping.\footnote{Since op-based \CRDTs require nice semantics
$P$, we cannot remove the dependence on $P$ without substantial alternation to
the library. We leave this to future work, and discuss it in greater detail in
Chapter~\ref{chap:future-work}.}

For our purposes, we begin by specifying a strengthened Network locale as
follows:
\begin{isabelle}
~~~~~~~~\isakeyword{and}\ \=msg{\isacharunderscore}id{\isacharunderscore}unique{\isacharcolon}\ \={\isasymrbrakk}\ \={\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \=\kill
\isacommand{locale}\ network\ {\isacharequal}\ node{\isacharunderscore}histories\ history\\
~~~~\isakeyword{for}\>history\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}msg\ event\ list{\isachardoublequoteclose}\ {\isacharplus}\\
~~~~\isakeyword{fixes}\>msg{\isacharunderscore}id\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}msg\ {\isasymRightarrow}\ {\isacharprime}msgid{\isachardoublequoteclose}\\
~~~~\isakeyword{assumes}\ delivery{\isacharunderscore}has{\isacharunderscore}a{\isacharunderscore}cause{\isacharcolon}\\
\>\>{\isasymlbrakk}\ {\isachardoublequoteopen}Deliver\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>\>{\isasymrbrakk}\ {\isasymLongrightarrow}\ {\isasymexists}j{\isachardot}\ Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ j{\isacharparenright}{\isachardoublequoteclose}\\
~~~~~~~~\isakeyword{and}\>deliver{\isacharunderscore}locally{\isacharcolon}\ \>{\isasymlbrakk}\ \>{\isachardoublequoteopen}Broadcast\ m\ {\isasymin}\ set\ {\isacharparenleft}history\ i{\isacharparenright}\ \>{\isasymrbrakk}\ {\isasymLongrightarrow}\  Broadcast\ m\ {\isasymsqsubset}\isactrlsup i\ Deliver\ m{\isachardoublequoteclose}\\
\end{isabelle}

Removing this assumption immediately invalidates many of the proofs contained
within the $\isa{network}$ locale. These proofs are broken due to a variety of
reasons, ranging form something as simple as referencing a now-missing
assumption, to more complex issues, e.g., a proof which relies on the uniqueness
of delivered messages.

We now describe our strategy for repairing these proofs:
\begin{enumerate}
  \item First, remove the assumption
    $\isa{msg}\isacharunderscore\isa{id}\isacharunderscore\isa{unique}$ from the
    $\isa{network}\isacharunderscore\isa{with}\isacharunderscore\isa{ops}$
    locale, as above.
  \item Identify the set of broken proofs. In each broken proof, do the
    following:
    \begin{enumerate}
      \item Identify the earliest broken proof step.
      \item Delete it and all proof steps following it.
      \item Replace the proof body with the term $\isakeyword{sorry}$.
    \end{enumerate}
  \item In any order, consider a proof which ends with $\isakeyword{sorry}$, and
    repair the proof.
\end{enumerate}

In total, there were four (4) key lemmas which needed repair. These were:
$\isa{hb}\isacharunderscore\isa{antisym}$,
$\isa{hb}\isacharunderscore\isa{has}\isacharunderscore\isa{a}\isacharunderscore\isa{reason}$,
$\isa{hb}\isacharunderscore\isa{cross}\isacharunderscore\isa{node}\isacharunderscore\isa{delivery}$, and
$\isa{hb}\isacharunderscore\isa{broadcast}\isacharunderscore\isa{broadcast}\isacharunderscore\isa{order}$.
After removing the
$\isa{msg}\isacharunderscore\isa{id}\isacharunderscore\isa{unique}$ assumption,
each of the above four proofs were able to be repaired automatically by
Isabelle's proof search keyword $\isakeyword{sledgehammer}$~\citep{wenzel02}.

In each of the \CRDTs that we do verify, we are required to instantiate a lemma
stating:
\[
  \isa{apply}\isacharunderscore\isa{operations}~\isa{xs}~\isacharequal~
  \isa{apply}\isacharunderscore\isa{operations}~\isa{ys}
\]
where $\isa{xs}$ and $\isa{ys}$ are lists of messages delivered to a pair of
replicas by the network. In other words, no matter what messages are delivered
in what order, the two replicas attain the same state. Following the original
proofs provided for op-based \CRDTs in~\citep{gomes17}, our proofs of this lemma
make the standard assumption that:
\[
  \isakeyword{set}~(\isa{node}\isacharunderscore\isa{deliver}\isacharunderscore\isa{messages}~\isa{xs})~\isacharequal~
  \isakeyword{set}~(\isa{node}\isacharunderscore\isa{deliver}\isacharunderscore\isa{messages}~\isa{ys})
\]
Note that although we require that the set of operations delivered at two nodes
is identical in order for those two nodes to attain the same value, we are able
to reason over an expanded set of network behaviors. For example, if some
message $m$ appears in either of the two sets above, we know that it only
appears in that node's history once, by the
$\isa{msg}\isacharunderscore\isa{id}\isacharunderscore\isa{unique}$ assumption.
But without that assumption, we know instead that it appears \emph{at least}
once in each of the node's log of history.

This is a key distinction, since not knowing how many times a message was
delivered to either of the two replicas means that we are able to conclude that
they reach the same state if the same set of messages is delivered \emph{at
least once} to each of the replicas. Said otherwise, it does not matter how many
times a message was delivered at each of two replicas, so long as it was
delivered at least once at both. This allows us to exercise the latter case of
Example~\ref{example:state-op-dup-msgs} using the strengthened network model.

\section{State-based \CRDTs}
Equipped with a relaxed network model, we are now ready to verify two examples
of state-based \CRDTs.

\subsection{State-based GCounter}
We begin first with the GCounter, the formal definition of which can be found in
Section~\ref{sec:example-gcounter}. Following our intuition in
Maxim~\ref{maxim:state-as-op}, we define a type to represent the $\isa{state}$ and
$\isa{operation}$ of a state-based G-Counter, presented below:

\begin{figure}[H]
  \input{figures/theories/gcounter-state}
  \caption{Isabelle definitions for $\isa{state}$ and $\isa{operation}$ for a
    state-based G-Counter \CRDT.}
\end{figure}

Here, we let the state be a partial mapping from a transparent
$\isacharprime\isa{id}$ type (the value of which uniquely identifies a replica
in the system) to an $\isa{int}$ which specifies the number of increment
operations performed at that replica. Like in
Section~\ref{sec:example-gcounter}, this defines a vector-like object, where
each slot in the vector corresponds to the number of increment operations
performed at some unique replica in the system. We define this mapping to be
partial, where the $\isa{None}$ value signals that no increments have been
performed at a given node.\footnote{This choice is arbitrary, and could have
easily have been implemented as mapping to $0$ instead.}

Next we define the operation to be a type-level synonym for the
$\isacharprime\isa{id}~\isa{state}$ type. This encodes that operations
\emph{are} states. We interpret that upon receipt of an operation that we
replace our current state with the join of it and the state encoded by the
operation, which is an implementation of Maxim~\ref{maxim:state-as-op}.

Before introducing the interpretation of
$\isa{gcounter}\isacharunderscore\isa{op}$ (which will be responsible for
performing this join operation as described), we look at a few other functions
which are defined to act over this type:

\begin{figure}[H]
  \input{figures/theories/gcounter-misc}
  \caption{Isabelle definitions for state-based GCounter-related functions.}
  \label{fig:gcounter-option-max}
\end{figure}

The function $\isa{inc}$ specifies (for demonstration purposes) how to increment
the value in a vector for some node. That is, $\isa{inc}$ specifies the
procedure to execute when an increment operation is performed at some replica.
Since our proofs reason purely about transitions of states, and not the external
forces that drive them, this function is never called by our proofs, but merely
left for the reader as a demonstration of how to drive the system.

The other function $\isa{option}\isacharunderscore\isa{max}$ specifies the
pair-wise maximum of two $\isa{int}~\isa{option}$ values. Note that these are
the right-hand side of the mapping in $\isacharprime\isa{id}~\isa{state}$, and
so this function is used to merge the state received from some other replica.
We will prove some additional facts about this function shortly, but for now we
interpret it as taking the maximum of two optional integers, where a present
integer is always preferred over an absent one\footnote{That is, the maximum of
$\isa{Some}~x$ and $\isa{None}$ is $\isa{Some}~x$.}, and the maximum of two
absent integers is $\isa{None}$.

Now that we have a way to interpret the pair-wise maximum of two states which
constitute a join, we can specify our definition of the ``operation'' for a
state-based G-Counter \CRDT. Recall that as in Maxim~\ref{maxim:state-as-op}, we
need to specify an operation which is the join of two states. We present now the
definition as used in our proofs:

\begin{figure}[H]
  \input{figures/theories/gcounter-state-op}
  \caption{Isabelle definition for the ``operation'' of a state-based G-Counter
    \CRDT.}
\end{figure}

Here, we specify a function that produces a partial mapping from an operation
and state to a new state. The function is not total (that is, it \emph{can}
return $\isa{None}$ for some input) to indicate a crash. For our purposes, the
function \emph{is} total, that is, it never returns $\isa{None}$ for any
input.\footnote{Note that this $\isa{None}$ is different from the partial
mapping of the $\isacharprime\isa{id}~\isa{state}$ type, which specifies that
the \emph{count} of increment operations at some replicas may zero. Returning
$\isa{None}$ from $\isa{gcounter}\isacharunderscore\isa{op}$ indicates that
there is no state at all, i.e., a crash has occurred.} Here, the state on the
left-hand side indicates the state that our replica currently has. The
``operation'' so-to-speak is the state at some \emph{other} replica. By encoding
the state from a remote replica in this fashion, we are implicitly saying that
this state should be joined with our current state, and that the result of this
join should replace our current state. So, we return a new state, which is a
function which maps node identifiers to the maximum of the associated value
between our previous state, and the state at some other replica.

For example, if our state in a four-replica system is:
\[
  \{ r_1 : 1,\, r_2 : \bot,\, r_3 : 2,\, r_4 : \bot \}
\]
and the state of some replica is:
\[
  \{ r_1 : \bot,\, r_2 : 1,\, r_3 : 3,\, r_4 : \bot \}
\]
the resulting state is:
\[
  \{ r_1 : 1,\, r_2 : 1,\, r_3 : 3,\, r_4 : \bot \}
\]

In Isabelle, we encode this as a function which forms a closure over the local
and remote states, and then computes the maximum some given node identifier
$\isa{x}$. In practice, this is the lazy equivalent to computing all of the
values up front upon merging.

Now that we have an instantiation of how to modify and merge states (the
equivalent of the $u$ and $m$), it remains to show that this is a suitable
initiation of the
$\isa{strong}\isacharunderscore\isa{eventual}\isacharunderscore\isa{consistency}$
locale.\footnote{Recall that instating this locale is equivalent to a proof that
the object it is being instantiated with has \SEC.}

A first-try instantiation shows that it is not possible to do so without
additional proofs. Upon inspecting the unmet goals, we can deduce that Isabelle
wants a proof of the commutativity and associativity of
$\isa{option}\isacharunderscore\isa{max}$, the key function used to implement
the merge of two states. We leave the full definitions of these proofs to
Section~\ref{sec:app-gcounter-comm-assoc}; most are able to be completed with
induction and term simplification only, and so are not of great interest to this
section.

Once we have a proof of commutativity and associativity (Isabelle can infer that
$\isa{option}\isacharunderscore\isa{max}$ is idempotent automatically), we then
state an important lemma and corollary, which are as follows:

\begin{figure}[H]
  \input{figures/theories/gcounter-commute}
  \caption{Isabelle proofs that concurrent operations commute in the state-based
    G-Counter.}
\end{figure}

\begin{figure}[H]
  \input{figures/theories/gcounter-convergence}
  \caption{Isabelle proofs that the state-based G-Counter is convergent.}
\end{figure}

This and the above proof establish the following two facts:
\begin{itemize}
  \item Operations that have been delivered at some node can be applied in any
    order up to causality and still achieve the same state (there is a more
    general result, since \emph{all} operations on the G-Counter are concurrent,
    but we specialize to showing a more specific case to guide Isabelle's reuse
    of the proof).
  \item Having the same set of operations delivered at any two replicas ensures
    that those replicas are in the same state.
\end{itemize}

The first property is a helpful lemma which is used in internal proofs, but the
second lemma should be familiar to the reader: this is the safety property of
\SEC! Note also that this is the first time that we are seeing our efforts in
weakening the network model bear fruit. That is, even though the two \emph{sets}
must be equal, we do not make a restriction on the number of times that a
particular message is delivered at either node. This allows us to prove a
stronger result that this \CRDT achieves a consistent result despite the number
of times that a message was (or was not) duplicated.

Finally, once we have shown these two properties, we can instantiate the
$\isa{strong}\isacharunderscore\isa{eventual}\isacharunderscore\isa{consistency}$
locale, which is witness to the fact that this \CRDT object achieves \SEC. We
present the instantiation now, and leave the proof to
Section~\ref{sec:app-gcounter-comm-assoc}:

\begin{figure}[H]
  \input{figures/theories/gcounter-state-sec}
  \caption{Isabelle proof that the state-based G-Counter \CRDT is \SEC.}
\end{figure}

Incidentally by this point, the proof that \SEC is inhabited by our encoding of
the G-Counter \SEC is mostly automatic, up to giving Isabelle some hints about
rewrite and simplification rules that it should apply.

\subsection{State-based GSet}
\label{sec:state-gset}

Now that we have verified a state-based G-Counter \CRDT, we turn our attention
to the other \CRDT object for study in this thesis. This will be the state-based
G-Set, which is described in detail in Section~\ref{sec:example-gset}. Readers
may notice that the remaining sections in this chapter are shorter and shorter
as we build up and reuse techniques from earlier proofs in later ones.

For now, we begin with an instantiation of the state-based G-Set \CRDT, as
follows:

\begin{figure}[H]
  \input{figures/theories/gset-state}
  \caption{Isabelle types for the state and operations of a state-based G-Set.}
\end{figure}

Like in Figure~\ref{fig:gset-state}, we parameterize the \CRDT on the type of
element in the set, which we denote in Isabelle as $\isacharprime\isa{a}$.
Similar to our offers in the previous sub-section, we define the
$\isa{operation}$ type to be a type-level synonym for the $\isa{state}$ type,
which we interpret in the same way (that is, that receiving an ``operation''
from some other replica is equivalent to being told to merge our state with the
received one, and replace our current state with the result).

Next, we define a simple insertion operation:

\begin{figure}[H]
  \input{figures/theories/gset-state-op}
  \caption{Isabelle definition of the insertion operation for a state-based
    G-Set.}
\end{figure}

Again, we define an operation $\isa{insert}$ for demonstration
purposes.\footnote{Again, our proofs reason about state \emph{transitions}.} Now
that we have a convenience function for generating states that could be used to
drive state transitions within the system, we can instate the interpretation of
an operation at a state-based G-Set \CRDT. This is the second function in the
above Isabelle snippet. Like the state-based G-Counter \CRDT, we map a pair of
$\isacharprime\isa{a}~\isa{operation}$ and $\isacharprime\isa{a}~\isa{state}$ to
a new state of the same type, or $\isa{None}$.\footnote{The existing library
in~\citep{gomes17} requires that this function be a partial mapping, but we do
not specify any behaviors which would cause our node to crash in ordinary
execution here.}

Faithful to the original specification in Figure~\ref{fig:gset-state}, we
interpret the join of two states (that is, two sets of items, one per replica)
as the merge operation.

Because we are using Isabelle's $\isa{set}$ library and its built-in function
$\cup$, we can leverage proofs about built-in Isabelle types, including the fact
that $\cup$ is commutative, associative, and idempotent. Therefore, unlike our
experience in the previous sub-section when specifying the state-based G-Counter
\CRDT, we do not need to prove these facts ourselves.\footnote{Recall that in
this instance, we were using a user-defined function
$\isa{option}\isacharunderscore\isa{max}$, and had an expanded obligation to
prove that this function was commutative and associative; Isabelle inferred
idempotence automatically.}

Aside from some additional proofs which are standard to all of our
instantiations of \CRDTs using the library from~\citep{gomes17}, we can
immediately instantiate the
$\isa{strong}\isacharunderscore\isa{eventual}\isacharunderscore\isa{consistency}$
locale without additional proof. We present the statement of this locale below,
and leave it and the additional proofs about the state-based G-Set to
Section~\ref{sec:app-state-gset}.

\begin{figure}[H]
  \input{figures/theories/gset-state-sec}
  \caption{Isabelle instantiation of the
    $\isa{strong}\isacharunderscore\isa{eventual}\isacharunderscore\isa{consistency}$
    locale for the state-based G-Set.}
\end{figure}

\section{$\delta$-state based \CRDTs}
\label{sec:isabelle-delta-crdts}

We have reached the climax of this chapter in which we now set out to verify
that $\delta$-state based \CRDT equivalents of the G-Counter and G-Set are also
inhabitants of the \SEC locale.

But in fact, we have already established this goal. Recall our statement in
Maxim~\ref{maxim:delta-as-state} that all $\delta$-state \CRDTs are themselves
$\delta$-state based \CRDTs, only with additional restriction on what states are
sent to other replicas. All that suffices to show is that restricted executions
of the datatype--that is, ones in which only $\delta$-state fragments are sent,
and not full state--still inhabit the \SEC locale.

Recall that, since our proofs reason about state transitions inductively, we
have implicitly covered the case in which only $\delta$-fragments of state are
exchanged between replicas. This is a consequence of our encoding of
$\delta$-state \CRDTs as op-based \CRDTs, and the fact that all $\delta$-based
\CRDT messages are also state-based \CRDT messages.

Since we have verified our \CRDTs as inhabiting the \SEC locale over all
possible operations, we produced proofs for $\delta$-state \CRDTs as a
side-effect of our strategy in Maxims~\ref{maxim:state-as-op}
and~\ref{maxim:delta-as-state}.

We devote the remainder of this section to stating the types of the
operation-producing functions for the $\delta$-based \CRDT equivalents of the
G-Counter and G-Set.

\subsection{$\delta$-state based G-Counter}
\label{sec:isabelle-delta-gcounter}

We begin first with our full definition of the $\delta$-state based G-Counter
\CRDT. Like the state-based variant, we treat the state as a partial mapping
between a transparent node identifier type and an optional value, referring to
the number of increment operations performed locally at that node. Following
Maxim~\ref{maxim:state-as-op}, we treat the operation again as a type-level
synonym for the state.

Similar to our treatment of the state-based G-Counter \CRDT, we encode the state
as a partial mapping from the set of node identifiers to an integer number of
times that an increment operation was performed at the replica belonging to that
node identifier. Likewise, we treat the operation as a type-level synonym for
this definition of the state.

The only difference (besides renaming $\isa{gcounter}\isacharunderscore\isa{op}$
to $\isa{delta}\isacharunderscore\isa{gcounter}\isacharunderscore\isa{op}$) is
that: the function $\isa{update}$ does not ever return a value from the
underlying state which does not belong to the replica being updated. That is, we
return a state which is \emph{only} defined for the single replica being
updated.

The full definition of the updated operation function in Isabelle is as follows:

\begin{figure}[H]
  \input{figures/theories/delta-gcounter}
  \caption{Isabelle definition of the $\delta$-state G-Counter \CRDT.}
\end{figure}

Here, we return a $\delta$-state which is only defined for the single replica
identifier being incremented. That is, we only return a value which is not
$\isa{None}$ for the occurrence when the parameter $\isa{j}$ is bound to a value
which equals $\isa{who}$. When this is met, we increment the value in the state
by one, and return the sum.

Since the body of the $\delta$-based G-Counter \CRDT is the same, and only the
convenience function changed, all other proofs are the same. In
Section~\ref{sec:alternate-delta-encoding}, we discuss an alternative encoding
which limits the kind of messages being sent at the type-level to be restricted
only to $\delta$-fragments.

\subsection{$\delta$-state based G-Set}

Finally, we turn our attention to the remaining \CRDT instance: the G-Set.
Similar to our experience verifying the $\delta$-based G-Counter, the
specification of the \CRDT itself is identical to the original encoding in
Section~\ref{sec:state-gset}, following our intuition in
Maxim~\ref{maxim:delta-as-state}.

For completeness, we present the full instantiation of this type (again leaving
the additional proofs to the Appendix in Section~\ref{sec:app-delta-gset}):

\begin{figure}[H]
  \input{figures/theories/delta-gset}
  \caption{Isabelle definition of the $\delta$-state G-Set \CRDT.}
\end{figure}

Notice that our encoding is identical as in the state-based G-Set example, but
the definition of $\isa{insert}$ has changed. Instead of constructing and
sending the union of the current set and the singleton set containing the item
we wish to add, we construct only the singleton set.

This guides our understanding that if this \CRDT only sends messages that are
able to be generated from the modified $\isa{insert}$ function, that it will
achieve \SEC, and indeed we are able to instantiate the
$\isa{strong}\isacharunderscore\isa{eventual}\isacharunderscore\isa{consistency}$
locale over this type. Because our proofs are inductive over state
\emph{transitions}, we have implicitly proved the case where only
$\delta$-fragments are sent as well.

In the following section, we discuss an alternate encoding which permits a more
direct proof of this fact.

\section{Alternative encoding of the $\delta$-state reduction}
\label{sec:alternate-delta-encoding}

In this Section, we discuss an alternative encoding in Isabelle of
$\delta$-state \CRDTs. Our key insight following
Maxim~\ref{maxim:delta-as-state} is that in a system where the proofs are done
inductively over state transitions, all executions which only exchange
$\delta$-fragments are implicitly verified. That is, since these messages
comprise a subset of the set of messages which are sent by state-based \CRDTs,
our inductive hypothesis still holds, and the result is preserved for
$\delta$-state \CRDTs.

But the key restriction in Maxim~\ref{maxim:delta-as-state} is that
$\delta$-state \CRDTs are ordinarily allowed to send only \emph{fragments} of
their state, not the entire state.\footnote{This restriction does not hold for
certain anti-entropy algorithms which are implemented on top of $\delta$-based
\CRDTs~\citep{almedia18}. This left to future work and discussed briefly in
Section~\ref{sec:direct-delta-proofs}.} For our purposes, we devote the
remainder of this section to exploring how this restriction might be encoded at
the type level in our proofs in Isabelle.

The approach that we take here is to let the operation type be a type-level
synonym for a sort of refinement type of the state. Consider for a brief example
the G-Set \CRDT. Here, the full state is $\isacharprime\isa{a}~\isa{set}$, but
the $\delta$-fragments are singleton sets. Ordinarily we would make a type-level
alias from $\isacharprime\isa{a}~\isa{operation}$ to be the same as
$\isacharprime\isa{a}~\isa{state}$, but this is too permissive. Recall that the
operation--for our purposes--is analogous to the kind of the update message sent
between replicas. We want to encode that this can \emph{only} be the singleton
set, not any arbitrary set. To do this, we let the $\isa{operation}$ type be a
single element of $\isacharprime\isa{a}$ type, which we interpret as the
singleton set.

In the following sections, we will consider two examples of this restriction.
Note that we are proving the same thing, so the underlying proof statement is
unchanged. That is, in Section~\ref{sec:isabelle-delta-crdts} we were reasoning
about an inductive hypothesis over \emph{all} possible state transitions. In
this section, we are reasoning about smaller single transitions (e.g., in the
case of a G-Set, adding at most one element in each step), but this is still
sufficient to reason about all possible state transitions.

\subsection{Refined $\delta$-state based G-Counter}
We begin first with the $\delta$-state based G-Counter, and specify it using our
alternate encoding. Recall that in the original specification in
Section~\ref{sec:isabelle-delta-gcounter}, we let the state type be a (partial)
mapping from a transparent node identifier type $\isacharprime\isa{a}$ to
$\isa{nat}$.

Aliasing the operation type to be a type-level synonym for the state allowed our
$\delta$-state \CRDT instantiation to send \emph{any} message, which is too
permissive. Recall that in a $\delta$-state G-Counter, we typically send a
single update, e.g., $\{ r_1 \mapsto n \}$ for a single replica $r_1$
incrementing the number of operations performed up to $n$. We specify this
single-update in Isabelle as follows:

\begin{figure}[H]
  \input{figures/theories/delta-gcounter-refined-state}
  \caption{Isabelle definitions for the $\isa{state}$ and $\isa{operation}$
    types for the restricted $\delta$-based G-Counter.}
\end{figure}

Here, we encode the restriction that a $\delta$-state G-Counter can only send an
update about a single replica by encoding that its operation type is a pair of
a transparent node identifier value and the number of increments performed at
that node.

In the following figure, we present the remainder of the altered definitions to
work around this more restricted $\isa{operation}$ type.

\begin{figure}[H]
  \input{figures/theories/delta-gcounter-refined-ops}
  \caption{Isabelle definitions of the remainder of functions for the restricted
    $\delta$-state G-Counter.}
\end{figure}

In the above, we omit the definition of
$\isa{option}\isacharunderscore\isa{max}$, which is identical to
Figure~\ref{fig:gcounter-option-max}. First, we reimplement $\isa{inc}$ to
return a value of the correct type by constructing a pair of the node being
incremented, and the value that it is being incremented to. Now that this is
done, we update our implementation of
$\isa{delta}\isacharunderscore\isa{gcounter}\isacharunderscore\isa{op}$ to match
the new type. Again, we return a function which takes the pairwise maximum
between the old and new values corresponding to a given node. However, we can no
longer pass the given operation as input to this function, since it does not
have the same type as the state of our \CRDT in this encoding.

To address this, we \emph{convert} the operation into a state by constructing a
state which is only defined for the single node being updated, and returns
$\isa{None}$ for all other values. Once we have this, we can then call it with
an arbitrary node to take its pairwise maximum to generate an updated state.

After specifying the \CRDT using this alternate encoding, we did not have to
update any of our existing proofs developed in
Section~\ref{sec:isabelle-delta-gcounter}, since Isabelle was able to infer the
remainder of facts it needed to recheck our existing proofs.

\subsection{Refined $\delta$-state based G-Set}

In this section, we apply the same techniques to show that an alternate encoding
of the $\delta$-based G-Set still achieves \SEC. As illustrated
in~\ref{sec:alternate-delta-encoding} we replace the definition of the
$\isa{operation}$ type to only allow for restricted, single-element messages
as follows:

\begin{figure}[H]
  \input{figures/theories/delta-gset-refined-state}
  \caption{Isabelle definitions for the $\isa{state}$ and $\isa{operation}$
    types for the restricted $\delta$-based G-Set.}
\end{figure}

First observe that the underlying type for $\isacharprime\isa{a}~\isa{state}$ is
unchanged, but that the new type for $\isacharprime\isa{a}~\isa{operation}$ only
allows a single value to be communicated in messages between two nodes.

Faced with this additional restriction, we update our proofs accordingly.
Following the example in the previous section, we can imagine that our proofs
will need to be updated in two locations:
\begin{enumerate}
  \item The definition of $\isa{insert}$ will become simplified, since we will
    no longer have to refer to the current state when generating the message
    signaling an item has been inserted.
  \item The interpretation of the operation will become slightly more complex,
    since we will have to treat the incoming item \emph{encoded} in the operation
    as a singleton set, and will thus have to do that conversion.
\end{enumerate}

We include the updated definitions of these two functions in Isabelle below:

\begin{figure}[H]
  \input{figures/theories/delta-gset-refined-ops}
  \caption{Isabelle definitions of the remainder of functions for the restricted
    $\delta$-state G-Set.}
\end{figure}

Notice that our insertion operation became dramatically simpler. In fact, the
function is so simple, that it is the identity on its first
parameter. We could have dropped the second parameter from the function
entirely,\footnote{Making its type signature $\isacharprime\isa{a} \Rightarrow
(\isacharprime\isa{a}~\isa{operation})$.} but we leave it there to illustrate
the fact that it \emph{can} be ignored.

This simplification is balanced with a small amount of complexity added in the
$\isa{delta}\isacharunderscore\isa{gset}\isacharunderscore\isa{op}$ function,
which now constructs a singleton set from the incoming operation--referred
to as $\isa{a}$--into $\{~\isa{a}~\}$.

As before, Isabelle is able to infer the remaining set of facts given our
definitions above in order to check the unmodified proofs from the original
encoding.

\section{Conclusion}

In this Chapter, we motivated our rationale behind weakening the network model
on top of which we verify our \CRDTs. We described our proof strategy for
weakening the network model, and presented two example \CRDTs which we verified
on top of this network model. We began each example by showing the state-based
object, and a proof that each \CRDT inhabits the \SEC locale, even on the
weakened network model.

We then reasoned that our state-based example \CRDTs in fact establish the same
goal for $\delta$-state \CRDTs without additional modification, according to our
result in Maxim~\ref{maxim:delta-as-state}. Finally, we presented an alternate
encoding which restricts the set of messages nodes are allowed to send together,
which more closely approximates the set of messages that $\delta$-\CRDTs are
allowed to send, and again proved that this encoding is an inhabitant of \SEC.
